<!DOCTYPE html>
<html>

    <head>

        <meta charset="UTF-8">

        <title>Crypto Kingdoms - An Ethereum Blockchain Strategy Game</title>

        <meta name="description" content="An Ethereum blockchain strategy game. Grow your kingdom and attack other players to win the Ethereum prize!">
        <meta name="keywords" content="Crypto, Kingdoms, Kingdom, Ethereum, Blockchain, Smart Contract, Game, Strategy, Gold, MetaMask, Turn-Based, Army, Soldier, Spy, Wizard, Dragon, Castle">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link type="image/ico" href="./favicon.ico" rel="icon">

        <script type="text/javascript" src="vue.min.js"></script>
        <script type="text/javascript" src="web3.js"></script>

        <script type="text/javascript">
            var cryptoKingdomsContractABI = [
                {
                    "constant": false,
                    "inputs": [
                        {
                            "internalType": "uint256",
                            "name": "targetPlayerIndex",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "numberOfSoldiers",
                            "type": "uint256"
                        }
                    ],
                    "name": "attack",
                    "outputs": [],
                    "payable": false,
                    "stateMutability": "nonpayable",
                    "type": "function"
                },
                {
                    "inputs": [
                        {
                            "internalType": "uint256",
                            "name": "joinTimeSeconds",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "gameTimeSeconds",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "turnTimeSeconds",
                            "type": "uint256"
                        }
                    ],
                    "payable": false,
                    "stateMutability": "nonpayable",
                    "type": "constructor"
                },
                {
                    "anonymous": false,
                    "inputs": [
                        {
                            "indexed": false,
                            "internalType": "uint256",
                            "name": "goldExchanged",
                            "type": "uint256"
                        },
                        {
                            "indexed": false,
                            "internalType": "uint256",
                            "name": "soldierDeaths",
                            "type": "uint256"
                        },
                        {
                            "indexed": false,
                            "internalType": "uint256",
                            "name": "wizardDeaths",
                            "type": "uint256"
                        },
                        {
                            "indexed": false,
                            "internalType": "uint256",
                            "name": "dragonDeaths",
                            "type": "uint256"
                        }
                    ],
                    "name": "attackCompleted",
                    "type": "event"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "internalType": "uint256",
                            "name": "amount",
                            "type": "uint256"
                        }
                    ],
                    "name": "buildBanks",
                    "outputs": [],
                    "payable": false,
                    "stateMutability": "nonpayable",
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "internalType": "uint256",
                            "name": "amount",
                            "type": "uint256"
                        }
                    ],
                    "name": "buildBarracks",
                    "outputs": [],
                    "payable": false,
                    "stateMutability": "nonpayable",
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "internalType": "uint256",
                            "name": "amount",
                            "type": "uint256"
                        }
                    ],
                    "name": "buildCastles",
                    "outputs": [],
                    "payable": false,
                    "stateMutability": "nonpayable",
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "internalType": "uint256",
                            "name": "amount",
                            "type": "uint256"
                        }
                    ],
                    "name": "buildHovels",
                    "outputs": [],
                    "payable": false,
                    "stateMutability": "nonpayable",
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "internalType": "uint256",
                            "name": "amount",
                            "type": "uint256"
                        }
                    ],
                    "name": "buildMiningCamps",
                    "outputs": [],
                    "payable": false,
                    "stateMutability": "nonpayable",
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "internalType": "uint256",
                            "name": "kingdomIndex",
                            "type": "uint256"
                        },
                        {
                            "internalType": "string",
                            "name": "newName",
                            "type": "string"
                        }
                    ],
                    "name": "changeKingdomName",
                    "outputs": [],
                    "payable": false,
                    "stateMutability": "nonpayable",
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "internalType": "uint256",
                            "name": "targetPlayerIndex",
                            "type": "uint256"
                        }
                    ],
                    "name": "espionage",
                    "outputs": [],
                    "payable": false,
                    "stateMutability": "nonpayable",
                    "type": "function"
                },
                {
                    "anonymous": false,
                    "inputs": [],
                    "name": "gameEnded",
                    "type": "event"
                },
                {
                    "anonymous": false,
                    "inputs": [
                        {
                            "indexed": false,
                            "internalType": "string",
                            "name": "message",
                            "type": "string"
                        }
                    ],
                    "name": "hostMessage",
                    "type": "event"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "internalType": "string",
                            "name": "playerName",
                            "type": "string"
                        }
                    ],
                    "name": "joinGame",
                    "outputs": [],
                    "payable": true,
                    "stateMutability": "payable",
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "internalType": "string",
                            "name": "s",
                            "type": "string"
                        }
                    ],
                    "name": "message",
                    "outputs": [],
                    "payable": false,
                    "stateMutability": "nonpayable",
                    "type": "function"
                },
                {
                    "anonymous": false,
                    "inputs": [
                        {
                            "indexed": false,
                            "internalType": "string",
                            "name": "playerName",
                            "type": "string"
                        }
                    ],
                    "name": "newPlayerJoined",
                    "type": "event"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "internalType": "uint256",
                            "name": "amount",
                            "type": "uint256"
                        }
                    ],
                    "name": "recruitSoldiers",
                    "outputs": [],
                    "payable": false,
                    "stateMutability": "nonpayable",
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "internalType": "uint256",
                            "name": "amount",
                            "type": "uint256"
                        }
                    ],
                    "name": "recruitSpies",
                    "outputs": [],
                    "payable": false,
                    "stateMutability": "nonpayable",
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "internalType": "uint256",
                            "name": "targetPlayerIndex",
                            "type": "uint256"
                        }
                    ],
                    "name": "sabotage",
                    "outputs": [],
                    "payable": false,
                    "stateMutability": "nonpayable",
                    "type": "function"
                },
                {
                    "anonymous": false,
                    "inputs": [
                        {
                            "indexed": false,
                            "internalType": "uint256",
                            "name": "sabotagedGold",
                            "type": "uint256"
                        },
                        {
                            "indexed": false,
                            "internalType": "uint256",
                            "name": "sabotagedDragons",
                            "type": "uint256"
                        },
                        {
                            "indexed": false,
                            "internalType": "uint256",
                            "name": "sabotagedHovels",
                            "type": "uint256"
                        },
                        {
                            "indexed": false,
                            "internalType": "uint256",
                            "name": "sabotagedMiningCamps",
                            "type": "uint256"
                        },
                        {
                            "indexed": false,
                            "internalType": "uint256",
                            "name": "sabotagedBanks",
                            "type": "uint256"
                        },
                        {
                            "indexed": false,
                            "internalType": "uint256",
                            "name": "dragonsKilled",
                            "type": "uint256"
                        }
                    ],
                    "name": "sabotaged",
                    "type": "event"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "internalType": "address",
                            "name": "gameAddress",
                            "type": "address"
                        }
                    ],
                    "name": "setNextGame",
                    "outputs": [],
                    "payable": false,
                    "stateMutability": "nonpayable",
                    "type": "function"
                },
                {
                    "anonymous": false,
                    "inputs": [
                        {
                            "indexed": false,
                            "internalType": "string",
                            "name": "name",
                            "type": "string"
                        },
                        {
                            "indexed": false,
                            "internalType": "uint256",
                            "name": "detail",
                            "type": "uint256"
                        },
                        {
                            "indexed": false,
                            "internalType": "uint256",
                            "name": "info",
                            "type": "uint256"
                        },
                        {
                            "indexed": false,
                            "internalType": "uint256",
                            "name": "moreInfo",
                            "type": "uint256"
                        }
                    ],
                    "name": "spyReported",
                    "type": "event"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "internalType": "uint256",
                            "name": "amount",
                            "type": "uint256"
                        }
                    ],
                    "name": "summonWizards",
                    "outputs": [],
                    "payable": false,
                    "stateMutability": "nonpayable",
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "internalType": "uint256",
                            "name": "amount",
                            "type": "uint256"
                        }
                    ],
                    "name": "trainDragons",
                    "outputs": [],
                    "payable": false,
                    "stateMutability": "nonpayable",
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "turn",
                    "outputs": [],
                    "payable": false,
                    "stateMutability": "nonpayable",
                    "type": "function"
                },
                {
                    "anonymous": false,
                    "inputs": [],
                    "name": "turnCompleted",
                    "type": "event"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "gameNumber",
                    "outputs": [
                        {
                            "internalType": "uint256",
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "payable": false,
                    "stateMutability": "view",
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "gameStats",
                    "outputs": [
                        {
                            "internalType": "uint256",
                            "name": "version",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "numberPlayers",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "totalGold",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "totalPrizePool",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "gameStartTimeSeconds",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "gameDurationSeconds",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "gameTurns",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "gameTurnTimeSeconds",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "gameCurrentTurn",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "gameLeaderIndex",
                            "type": "uint256"
                        }
                    ],
                    "payable": false,
                    "stateMutability": "view",
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "nextGameAddress",
                    "outputs": [
                        {
                            "internalType": "address",
                            "name": "",
                            "type": "address"
                        }
                    ],
                    "payable": false,
                    "stateMutability": "view",
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "internalType": "uint256",
                            "name": "playerIndex",
                            "type": "uint256"
                        }
                    ],
                    "name": "playerAtIndex",
                    "outputs": [
                        {
                            "internalType": "string",
                            "name": "playerName",
                            "type": "string"
                        }
                    ],
                    "payable": false,
                    "stateMutability": "view",
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "playerStats",
                    "outputs": [
                        {
                            "internalType": "enum CryptoKingdoms.Race",
                            "name": "race",
                            "type": "uint8"
                        },
                        {
                            "internalType": "string",
                            "name": "kingdomName",
                            "type": "string"
                        },
                        {
                            "internalType": "uint256",
                            "name": "actions",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "gold",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "soldiers",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "spies",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "wizards",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "dragons",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "hovels",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "miningCamps",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "banks",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "barracks",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "castles",
                            "type": "uint256"
                        }
                    ],
                    "payable": false,
                    "stateMutability": "view",
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "previousGameAddress",
                    "outputs": [
                        {
                            "internalType": "address",
                            "name": "",
                            "type": "address"
                        }
                    ],
                    "payable": false,
                    "stateMutability": "view",
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "winner",
                    "outputs": [
                        {
                            "internalType": "enum CryptoKingdoms.Race",
                            "name": "race",
                            "type": "uint8"
                        },
                        {
                            "internalType": "string",
                            "name": "name",
                            "type": "string"
                        },
                        {
                            "internalType": "uint256",
                            "name": "actions",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "gold",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "soldiers",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "spies",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "wizards",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "dragons",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "hovels",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "miningCamps",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "banks",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "barracks",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "castles",
                            "type": "uint256"
                        }
                    ],
                    "payable": false,
                    "stateMutability": "view",
                    "type": "function"
                }
            ]
        </script>

        <style>
            @font-face {
                font-family: CryptoKingdomsFont;
                src: url(CryptoKingdomsFont.ttf);
            }

            @keyframes fadeIn {
                0% {
                    opacity: 0;
                }
                100% {
                    opacity: 1;
                }
            }

            @keyframes fadeInSlow {
                0% {
                    opacity: 0;
                }
                20% {
                    opacity: 0;
                }
                100% {
                    opacity: 1;
                }
            }

            @keyframes fadeOut {
                0% {
                    opacity: 1;
                }
                100% {
                    max-height: 0px;
                    opacity: 0;
                }
            }

            .fadeIn {
                animation: fadeIn 1.5s;
                -moz-animation: fadeIn 1.5s;    /* Firefox */
                -webkit-animation: fadeIn 1.5s; /* Safari and Chrome */
                -o-animation: fadeIn 1.5s;      /* Opera */
                animation-timing-function: ease-in;
                animation-fill-mode: forwards;
            }

            .fadeInSlow {
                animation: fadeInSlow 2.5s;
                -moz-animation: fadeInSlow 2.5s;    /* Firefox */
                -webkit-animation: fadeInSlow 2.5s; /* Safari and Chrome */
                -o-animation: fadeInSlow 2.5s;      /* Opera */
                animation-timing-function: ease-in-out;
                animation-fill-mode: forwards;
            }

            .fadeOut {
                font-size: 0;
                margin: 0;
                opacity: 0;
                padding: 0;
                max-height: 0px;
                transition: opacity 25s,
                            font-size 5s 25s,
                            margin 5s 25s,
                            padding 5s 25s,
                            max-height 5s 25s;
            }

            body {
                font-family: CryptoKingdomsFont;
                margin: 0px;
                padding: 0px;
            }

            h1 {
                font-size: 48px;
                text-align: center;
                margin: 0px;
                padding: 6px;
                position: fixed;
                margin-left: auto;
                margin-right: auto;
                width: 100%
                text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;
            }

            h2 {
                font-size: 18px;
                text-align: center;
                margin: 0px;
                padding: 4px;
            }

            p {
                font-size: 18px;
                text-align: center;
                margin: 18px;
                margin-left: 10%;
                margin-right: 10%;
            }

            @media only screen and (max-width: 400px), screen and (max-height: 400px) {

                h1 {
                    font-size: 20px;
                    text-align: center;
                    margin: 0px;
                    padding: 0px;
                    margin-top: 8px;
                    width: 100%
                }

                h2 {
                    font-size: 16px;
                    margin: 2px;
                    padding: 0px;
                    padding-top: 50px;
                }

                p {
                    font-size: 16px;
                    margin: 14px;
                }

            }

            @media only screen and (max-height: 300px) {

                p {
                    font-size: 14px;
                }

            }

            a:link {
                color: #0000ee;
            }

            a:visited {
                color: #0000ee;
            }

            a:hover {
                color: #66ccff;
            }

            a:active {
                color: #0000ee;
            }

            table {
                border-spacing: 0px;
                padding: 0%;
                margin: 0%;
                text-align: center;
                transition: all 1s;
            }

            td {
                transition: all 1s;
            }

            .unselectable {
                -khtml-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                user-select: none;
            }

            .hidden {
                display: none;
            }

            .tagline {
                font-size: 18px;
                text-align: center;
                margin: 2px;
                padding: 0px;
                padding-top: 80px;
            }

            .noEthereumConnectionMessage {
                font-size: 28px;
            }

            .noFont {
                font-family: none;
            }

            .countdownTimer {
                min-width: 230px;
            }

            .signedUp p {
                font-size: 24px;
                text-align: center;
                margin: 2px;
                padding: 2px;
            }

            .noSelect, .statsInfoButton, .actionButton {
              -webkit-touch-callout: none; /* iOS Safari */
                -webkit-user-select: none; /* Safari */
                 -khtml-user-select: none; /* Konqueror HTML */
                   -moz-user-select: none; /* Firefox */
                    -ms-user-select: none; /* Internet Explorer/Edge */
                        user-select: none; /* Non-prefixed version, currently
                                              supported by Chrome and Opera */
            }

            .newKingdomName {
                font-size: 22px;
            }

            #CryptoKingdoms {
                transition: 2s;
                transition-timing-function: ease-in-out;
            }

            #joinGameButton {
                font-size: 12px;
                padding: 8px 12px 8px 12px;
                margin: 12px;
            }

            #notInGame {
                transition: all 2s;
            }

            #header {
                display: flex;
                position: fixed;
                justify-content: center;
                margin: 0px;
                padding: 0px;
                margin-left: auto;
                margin-right: auto;
                width: 100%;
                z-index: 1;
            }

            #headerBackground {
                display: flex;
                position: fixed;
                z-index: -1;
                background-image: radial-gradient(white, white);
                filter: blur(8px);
                -webkit-filter: blur(8px);
                background-position: center;
                background-repeat: no-repeat;
                background-size: cover;
                border-radius: 90px;
                margin-left: auto;
                margin-right: auto;
                width: 460px;
                height: 77px;
            }

            @media only screen and (max-width: 400px), screen and (max-height: 400px) {

                #headerBackground {
                    border-radius: 90px;
                    width: 210px;
                    height: 44px;
                }

            }

            #icon {
                width: 32px;
                height: 32px;
            }

            #background {
                width: 100%;
                height: 100%;
            }


            /* Metamask */

            #metaMaskBanner {
                display: block;
                margin-left: auto;
                margin-right: auto;
                margin-bottom: 20px;
                left: 10%;
                right: 10%;
                width: 60%;
                animation: fadeIn 4s;
                -moz-animation: fadeIn 4s;    /* Firefox */
                -webkit-animation: fadeIn 4s; /* Safari and Chrome */
                -o-animation: fadeIn 4s;      /* Opera */
                animation-timing-function: ease-in-out;
                animation-fill-mode: forwards;
            }

            p.unlockMetaMask {
                font-family: "Trebuchet MS", Arial, Helvetica, sans-serif;
                font-size: 32px;
                text-align: center;
                animation: fadeIn 4s;
                -moz-animation: fadeIn 4s;    /* Firefox */
                -webkit-animation: fadeIn 4s; /* Safari and Chrome */
                -o-animation: fadeIn 4s;      /* Opera */
                animation-timing-function: ease-in-out;
                animation-fill-mode: forwards;
            }


            /* Account Status */

            .networkStatus {
                display: block;
                font-family: "Trebuchet MS", Arial, Helvetica, sans-serif;
                font-size: 10px;
                position: fixed;
                width: 100%;
                left: 0px;
                bottom: 0px;
            }

            .noAccountsSection {
                background-color: white;
                border: 1px solid black;
                height: 100%;
            }

            .accountInfoSection {
                background-color: white;
                border-top: 1px solid black;
                height: 100%;
            }

            .accountInfo {
                font-size: 14px;
                table-layout: fixed;
                border-collapse: collapse;
                width: 100%;
                margin: 0px;
            }

            .networkConnection {
                background-color: white;
            }

            p.networkConnection {
                font-size: 10px;
                text-align: left;
                position: fixed;
                padding: 2px 2px 2px 2px;
                margin: 2px;
                margin-bottom: 0px;
            }

            .time {
                background-color: white;
            }

            p.time {
                font-size: 10px;
                text-align: right;
                padding: 2px 2px 2px 2px;
                margin: 2px;
                margin-bottom: 0px;
            }

            .accountInfo th {
                background-color: #4a4037; /* #3c3c3d is Ethereum color. */
                color: white;
            }

            .accountInfo tr:nth-child(odd) {
                background-color: #f2f2f2;
            }

            .accountInfo tr:nth-child(even) {
                background-color: #f2f2f2;
            }

            .accountInfo td, .accountInfo th {
                text-align: center;
                padding: 10px;
                overflow-x: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            @media only screen and (max-width: 350px), screen and (max-height: 350px) {

                .accountInfo {
                    font-size: 10px;
                }

                .accountInfo td, .accountInfo th {
                    padding: 6px;
                }

                p.networkConnection {
                    font-size: 8px;
                }

                p.time {
                    font-size: 8px;
                }

            }

            @media only screen and (max-height: 300px) {

                .networkStatus {
                    display: none;
                }

            }


            /* Game */

            .game {
                display: block;
                text-align: center;
                margin-left: auto;
                margin-right: auto;
                animation: fadeIn 1s;
                -moz-animation: fadeIn 1;       /* Firefox */
                -webkit-animation: fadeIn 1s;   /* Safari and Chrome */
                -o-animation: fadeIn 1s;        /* Opera */
                animation-timing-function: ease-in-out;
                animation-fill-mode: forwards;
            }

            .gameStats {
                font-family: "Trebuchet MS", Arial, Helvetica, sans-serif;
                border-collapse: separate;
                border-radius: 6px;
                margin-left: auto;
                margin-right: auto;
            }

            .gameStats th {
                background-color: #4caf50;
                color: white;
            }

            .gameStats th, .gameStats td {
                border: 1px solid #ddd;
                padding: 8px;
            }

            .gameStats tr:nth-child(odd) {
                background-color: #f3f3f3;
            }

            .gameStats tr:nth-child(even) {
                background-color: #e2e2e2;
            }

            .gameStats p {
                margin: 0px;
                font-size: 16px;
            }

            .gameStat p {
                text-align: left;
            }


            /* Winner */

            .winnerStats {
                background-image: url("gold.jpg");
                font-family: "Trebuchet MS", Arial, Helvetica, sans-serif;
                text-align: center;
                border: 5px solid #f7ff95;
                border-radius: 30px;
                border-collapse: separate;
                margin-left: auto;
                margin-right: auto;
            }

            .winnerStats th {
                /*background-color: #ff3b2e;*/
            }

            .winnerStats th, .winnerStats td {
                border-collapse: collapse;
                padding: 12px;
                vertical-align: center;
            }

            .winnerStats tr:nth-child(odd) {
                /*background-color: #ffb233;*/
            }

            .winnerStats tr:nth-child(even) {
                /*background-color: #ff9900;*/
            }

            .winnerStats p {
                margin: 0px;
            }


            /* Player */

            .playerPanel {
                font-family: "Trebuchet MS", Arial, Helvetica, sans-serif;
                display: inline-block;
                margin-top: 0px;
                margin-bottom: 0px;
                margin-left: 5%;
                margin-right: 5%;
                padding: 0px;
                text-align: center;
            }

            .playerPanel td {
                border: 0px;
                padding-top: 1px;
                padding-bottom: 1px;
                vertical-align: middle;
                width: 33%;
            }

            .playerPanel p {
                margin: 0px;
            }

            @media only screen and (max-width: 500px) {

                .playerPanel {
                    font-size: 14;
                    width: auto;
                    margin-left: 1%;
                    margin-right: 1%;
                }

                .playerPanel td {
                    width: auto;
                }

            }

            .playerStats {
                vertical-align: middle;
                border: 2px solid #0d730d;
                border-collapse: separate;
                border-radius: 6px;
                overflow: hidden;
                margin: auto;
            }

            .playerStats th {
                background-color: #0d730d;
                color: white;
            }

            .playerStats th, .playerStats td {
                border-collapse: collapse;
                padding: 12px;
                vertical-align: middle;
            }

            .playerStats tr:nth-child(odd) {
                background-color: #87c639;
            }

            .playerStats tr:nth-child(even) {
                background-color: #87c839;
            }

            .playerStats tr:hover, .playerStats tr:active
            {
                background-color: #8ec94f;
            }

            .goldText {
                text-shadow: 0 0 25px rgba(255, 215, 0, 1.0);
            }

            .spiesCell {
                text-shadow: 0 0 60px rgba(30, 30, 30, 0.5);
            }

            .spiesCell .statsInfoPanel {
                text-shadow: none;
            }

            .attackPowerCell {
                background-color: darkred;
            }

            .defencePowerCell {
                background-color: darkblue;
            }

            @media only screen and (max-width: 500px), screen and (max-height: 500px) {

                .playerStats td {
                    padding: 6px;
                }

            }


            /* Player Actions */

            .playerActions {
                border: 2px solid #515151;
                border-radius: 6px;
                border-collapse: separate;
                margin-left: auto;
                margin-right: auto;
                overflow: hidden;
            }

            .playerActions th, .playerActions td {
                border: 1px solid #515151;
                padding: 10px;
                vertical-align: middle;
            }

            .playerActions th {
                background-color: #515151;
                color: white;
            }

            .playerActions td {
                cursor: pointer;
                text-shadow: -1px -1px 1px rgba(255, 255, 255, 0.2), 1px 1px 1px rgba(0, 0, 0, 0.2);
            }

            .playerActions tr:nth-child(odd) {
                background-color: #e2e2e2;
            }

            .playerActions tr:nth-child(even) {
                background-color: #f2f2f2;
            }

            .playerActions tr:hover, .playerActions tr:active {
                background-color: #ccc;
            }

            @media only screen and (max-width: 400px) {

                .playerActions td {
                    padding: 4px;
                    text-shadow: none;
                }

            }


            /* Player Listing */

            .playerListing {
                border: 2px solid #8a2100;
                border-radius: 6px;
                border-collapse: separate;
                text-align: center;
                overflow: hidden;
            }

            .playerListing tr:nth-child(odd) {
                background-color: #e0c3c3;
            }

            .playerListing tr:nth-child(even) {
                background-color: #e6c0c0;
            }

            .playerListing th {
                background-color: #8a2100;
                color: white;
            }

            .playerListing td, .playerListing th {
                border: 1px solid #8a2100;
                padding: 10px;
                vertical-align: center;
            }

            .playerListing td {
                cursor: pointer;
                text-shadow: 0px 0px 1px rgba(255, 255, 255, 0.1), 1px 1px 1px rgba(0, 0, 0, 0.1);
            }

            .playerListing tr:hover, .playerListing tr:active {
                background-color: #cc9999;
            }

            .playerListing p {
                margin: 0px;
            }

            @media only screen and (max-width: 400px), screen and (max-height: 400px) {

                .playerListing th, .playerListing td {
                    text-shadow: none;
                    margin-left: auto;
                    margin-right: auto;
                    padding: 4px;
                }

            }

            .playerListingMobileRotateTip {
                display: none;
            }

            @media (pointer: fine) {

                .playerListingDesktopTip {
                    display: block;
                }

                .playerListingMobileTip {
                    display: none;
                }
            }

            @media (pointer: coarse) {

                .playerListingDesktopTip {
                    display: none;
                }

                .playerListingMobileTip {
                    display: block;
                }
            }

            @media only screen and (max-width: 350px) and (pointer: coarse)   {

                .playerListing {
                    display: none;
                }

                .playerListingMobileRotateTip {
                    display: block;
                }

            }


            /* Info Panels */

            .statsInfoPanel, .actionInfoPanel, .attackInfoPanel, .espionageInfoPanel, .sabotageInfoPanel, .enchantInfoPanel, #leaderCrownInfoPanel {
                display: none;
                position: absolute;
                z-index: 1;
                background-image: url("parchment.jpg");
                background-color: #f1f1f1;
                min-width: 120px;
                max-width: 240px;
                border: 0.5px solid #4c4c4c5a;
                border-radius: 2px;
                border-collapse: separate;
                box-shadow: 4px 8px 16px 1px rgba(0, 0, 0, 0.25);
                margin-top: -20px;
                margin-left: 160px;
                padding: 5px;
            }

            .statsInfoPanel {
                margin-left: 15%;
                margin-top: 1%;
            }

            .kingdomNameInfoPanel {
                margin-left: 200px;
            }

            .actionInfoPanel, .attackInfoPanel {
                margin-left: 150px;
                margin-top: -30px;
            }

            .attackInfoPanel {
                max-width: 260px;
                margin-top: -400px;
            }

            .espionageInfoPanel {
                max-width: 260px;
                margin-left: 160px;
                margin-top: -160px;
            }

            .sabotageInfoPanel {
                max-width: 260px;
                margin-left: 160px;
                margin-top: -200px;
            }

            .enchantInfoPanel {
                max-width: 260px;
                margin-left: 160px;
                margin-top: -180px;
            }

            #leaderCrownInfoPanel {
                max-width: 260px;
                margin-left: -240px;
                margin-top: -80px;
            }

            .statsInfoPanel p, .actionInfoPanel p, .attackInfoPanel p, .espionageInfoPanel p, .sabotageInfoPanel p, #leaderCrownInfoPanel p {
                display: block;
                color: black;
                font-size: 14px;
                padding: 4px;
                margin: 4px;
                text-decoration: none;
                text-shadow: none;
            }

            .statsInfoButton:hover .statsInfoPanel, .statsInfoButton:active .statsInfoPanel,
            .actionButton:hover .actionInfoPanel, .attackButton:hover .attackInfoPanel,
            .espionageButton:hover .espionageInfoPanel, .sabotageButton:hover .sabotageInfoPanel,
            .enchantButton:hover .enchantInfoPanel, #leaderCrown:hover #leaderCrownInfoPanel {
                display: block;
            }

            @media only screen and (max-width: 350px), screen and (max-height: 350px) {

                .statsInfoPanel {
                    margin-left: 80px;
                }

                .statsInfoPanel p, .actionInfoPanel p, .attackInfoPanel p, .espionageInfoPanel p, .sabotageInfoPanel p, #leaderCrownInfoPanel p {
                    font-size: 14px;
                    padding: 2px;
                    margin: 2px;
                }

                .actionInfoPanel {
                    margin-left: -60px;
                }

                .attackInfoPanel {
                    max-width: 260px;
                    margin-left: -60px;
                    margin-top: -400px;
                }

                .espionageInfoPanel {
                    max-width: 260px;
                    margin-left: -60px;
                    margin-top: -160px;
                }

                .sabotageInfoPanel {
                    max-width: 260px;
                    margin-left: -60px;
                    margin-top: -200px;
                }

            }

            @media only screen and (max-width: 500px) {

                .statsInfoPanel {
                    margin-left: 150px;
                    margin-top: 1%;
                }

                .actionInfoPanel, .attackInfoPanel, .espionageInfoPanel, .sabotageInfoPanel {
                    margin-left: -60px;
                }

                .attackInfoPanel {
                    max-width: 260px;
                    margin-top: -400px;
                }

                .espionageInfoPanel {
                    max-width: 260px;
                    margin-top: -160px;
                }

                .sabotageInfoPanel {
                    max-width: 260px;
                    margin-top: -200px;
                }

            }


            /* Events */

            .eventLog {
                margin-bottom: 36px;
                margin-left: auto;
                margin-right: auto;
                width: 80%;
                max-width: 1000px;    
            }

            .eventLogFullscreen {
                margin-left: 20px;
                margin-right: 20px;
                width: 100%;
                height: 100%; /* Full Log is displayed without content scrollbar. */
            }

            .eventLogTitle {
                text-align: left;
                margin-top: 0px;
                margin-bottom: 8px;
                margin-left: 10px;
            }

            .eventMessageBox {
                background-image: url("eventbackground.jpg");
                background-size: 47568px 73696px;
                background-position: center;
                border: 1px solid black;
                border-radius: 6px;
                border-collapse: separate;
                overflow: scroll;
                height: 360px;
            }

            .eventMessageBoxFullscreen {
                width: 100%;
                height: 100%;
            }

            .eventMessages {
                padding: 4px 2% 4px 2%;
            }

            .eventMessages th {
                background-color: #4caf50;
                color: white;
            }

            .eventMessages th, .eventMessages td {
                padding: 0px;
                text-align: left;
            }

            .eventMessages td {
                text-align: left;
                vertical-align: middle;
                padding: 0px 10px 0px 10px;
            }

            .eventMessages tr:nth-child(odd) {
                color: #000000;
            }

            .eventMessages tr:nth-child(even) {
                color: #2d2d00;
            }

            .eventMessages p {
                text-align: left;
                margin: 0px;
                padding: 1px;
            }

            #waitingMessage {
                border-radius: 6px;
                margin: 1%;
                margin-left: auto;
                margin-right: auto;
                max-width: 500px;
            }

            #waitingMessageText {
                margin: 1%;
            }

            #waitingSpinner {
                display: inline;
                width: 64px;
                height: 64px;
            }

            @media only screen and (max-width: 400px) {

                .eventMessages td {
                    text-align: left;
                    vertical-align: middle;
                }

            }

            /* Army Unit Animations */

            .armyUnit {
                position: fixed;
                font-size: 28px;
                width: 50%;
                margin: -2.7%;
                margin-left: 100%;
                margin-top: -31px;
            }

            .armyUnitMoveSneakInLeft {
                animation: armyUnitMoveInLeft1Keyframes 10s;
                -moz-animation: armyUnitMoveInLeft1Keyframes 10s;    /* Firefox */
                -webkit-animation: armyUnitMoveInLeft1Keyframes 10s; /* Safari and Chrome */
                -o-animation: armyUnitMoveInLeft1Keyframes 10s;      /* Opera */
                animation-timing-function: ease-out;
                animation-fill-mode: forwards;
            }
        </style>

    </head>

    <body>

        <script>

            // Setup Log

            logging = true

            function log()
            {
                if (logging) {
                    console.log.apply(this, arguments)
                }
            }

            console.log("%cCrypto Kingdoms JavaScript Console", "color: black; font-size: 14px;");

            // Prepare the Ethereum!

            // Check if Web3 has been loaded by the web browser (Mist / MetaMask in Chrome).
            hasEthereum = false
            if (typeof ethereum !== 'undefined') {
                web3 = new Web3(ethereum)
                try {
                    ethereumEnableStatus = ethereum.enable()
                    log("Ethereum Web3 API " + web3.version.api)
                    hasEthereum = true
                }
                catch (error) {
                    log("Error Enabling Ethereum:", error)
                }
            }
            else if (typeof web3 !== "undefined") {
                web3 = new Web3(web3.currentProvider)
                log("Web3 API " + web3.version.api)
                hasEthereum = true
            }
            else {
                // Use some fallback strategy (local node / hosted node + in-dapp id mgmt / fail).
                // web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));
                log("Failed to load web3. This is going to cause problems for this site...")
                web3 = undefined
            }

        </script>

        <div id="CryptoKingdoms" v-bind:class="{ noFont : disableFont }" v-bind:style="bodyBackground">

            <div id="background" v-on:click="clearTooltip">

                <div id="header">
                    <div id="headerBackground"></div>
                    <h1 v-bind:style="title">CryptoKingdoms.org</h1>
                </div>

                <h2 class="tagline" v-bind:style="topText">A Strategy Game on the Ethereum Blockchain</h2>

                <div class="fadeIn noEthereumConnectionMessage" v-if="!hasEthereum || typeof web3 === 'undefined'" v-bind:style="topText">
                    <p v-bind:style="topText">You're not currently connected to the Ethereum network! You need to use an Ethereum enabled web browser to play Crypto Kingdoms!</p>
                    <p v-bind:style="topText">You can use Google Chrome if you install the <a href="https://metamask.io" target="_blank">MetaMask Chrome extension</a>.</p>
                    <p v-bind:style="topText">You can use Firefox if you install the <a href="https://addons.mozilla.org/en-GB/firefox/addon/ether-metamask" target="_blank">MetaMask Firefox extension</a>.</p>
                    <p v-bind:style="topText">You can use an iPhone or iPad if you download the app <a href="https://apps.apple.com/us/app/coinbase-wallet/id1278383455" target="_blank">Coinbase Wallet</a>.</p>
                    <p v-bind:style="topText">You can use Android if you download the app <a href="https://play.google.com/store/apps/details?id=org.toshi" target="_blank">Coinbase Wallet & DApp Browser</a>.</p>
                    <!-- <p>You can also use the <a href="https://github.com/ethereum/mist/releases">Mist</a> web browser on Linux, macOS, and Windows (not recommended).</p> -->
                    <p>Please come back and refresh this page once you've added the extension.</p>
                    <br>
                    <h2>More Information...</h2>
                    <p v-bind:style="topText">Crypto Kingdoms is a strategy game built on the Ethereum blockchain. Playing the game is a great way to learn about blockchain technology while having fun playing a game.</p>
                    <p v-bind:style="bottomText">The MetaMask Chrome extension (or mobile apps) will allow you to create an Ethereum wallet that will hold an Ethereum address that can be used to transfer Ethereum to and from any other Ethereum address. It also enables browsing of Ethereum-enabled websites such as Crypto Kingdoms which uses an Ethereum smart contract to host a multiplayer strategy game with a prize!</p>
                    <p v-bind:style="bottomText">You don't have to spend any real Ethereum to play the game - just switch your MetaMask extension or browser app to the Ropsten test network, request some free test Ethereum and join us on the test game! But first, get the Ethereum browser extension or mobile app from one of the links above!</p>
<!--                     <p v-bind:style="bottomText">Click the banner below to go to the download page for MetaMask (for Google Chrome) or use the links above to download an Ethereum web browser app. Come back to this page once you've installed the extension or browser app!</p>
 -->                <p v-bind:style="bottomText">{{ helpText }} <a href="mailto:admin@cryptokingdoms.org" target="_top">admin@cryptokingdoms.org</a></p>
<!--                     <a href="https://metamask.io" target="_blank"><img id="metaMaskBanner" src="https://github.com/MetaMask/faq/raw/master/images/download-metamask.png" alt="Download MetaMask Button"></a>
 -->                
                </div>
                <div v-else-if="hasEthereum">

                    <div v-if="web3 && (gameStats.version == 0)">
                        <br>
                        <p>Couldn't find the active game! 😱</p>
                        <br>
                        <div v-if="networkVersion != 0">
                            <p><strong>You need to switch to the "Main Ethereum Network" in MetaMask or in your app's settings.</strong></p>
                            <br>
                            <br>
                            <br>
                        </div>
                        <div v-else>
                            <p>You may need to refresh the page or restart Google Chrome.</p>
                            <br>
                            <p>The blockchain may need a moment to sync.</p>
                            <br>
                        </div>
                        <br><br><br><br>
                    </div>
                    <div v-else class="hidden game">

                        <!-- Welcome Message -->
                        <div v-if="gameStats.gameCurrentTurn !== undefined && gameStats.gameTurns">
                            <p v-bind:style="topText">Welcome {{ (isInGame && gameStats.gameCurrentTurn - playerStats.actions < 20) ? "back to" : "to" }} Crypto Kingdoms!</p>
                            <div v-if="gameStats.gameCurrentTurn <= 0">
                                <p v-bind:style="topText">A new game is about to begin!</p>
                            </div>
                            <div v-else-if="gameStats.gameCurrentTurn < (gameStats.gameTurns * 3 / 10)">
                                <p v-bind:style="topText">A new game has just begun!</p>
                            </div>
                            <div v-else-if="gameStats.gameCurrentTurn == (gameStats.gameTurns / 2)">
                                <p v-bind:style="topText">A game has currently reached its half way point!</p>
                            </div>
                            <div v-else-if="gameStats.gameCurrentTurn < (gameStats.gameTurns * 3 / 4)">
                                <p v-bind:style="topText">A game is currently under way!</p>
                            </div>
                            <div v-else-if="gameStats.gameCurrentTurn < (gameStats.gameTurns * 7 / 10)">
                                <p v-bind:style="topText">A game is currently under way!</p>
                            </div>
                            <div v-else-if="gameStats.gameCurrentTurn < (gameStats.gameTurns * 8 / 10)">
                                <p v-bind:style="topText">A game is currently in its final chapter!</p>
                            </div>
                            <div v-else-if="gameStats.gameCurrentTurn < (gameStats.gameTurns * 9 / 10)">
                                <p v-bind:style="topText">A game is currently in its final inning!</p>
                            </div>
                            <div v-else-if="gameStats.gameCurrentTurn < (gameStats.gameTurns * 19 / 20)">
                                <p v-bind:style="topText">A game is currently approaching its end!</p>
                            </div>
                            <div v-else-if="gameStats.gameCurrentTurn < (gameStats.gameTurns * 195 / 200)">
                                <p v-bind:style="topText">A game is currently reaching its final conclusion!</p>
                            </div>
                            <div v-else-if="gameStats.gameCurrentTurn < gameStats.gameTurns">
                                <p v-bind:style="topText">A game is currently playing out its final moments!</p>
                            </div>
                            <div v-else-if="0 >= (gameStats.gameTurns - gameStats.gameCurrentTurn)">
                                <p>The game has ended! Thank you for playing!</p>
                            <div v-else>
                                <p v-bind:style="topText">There's currently a game in progress!</p>
                            </div>
                        </div>
                        <div v-else>
                            <p v-bind:style="topText">There's currently a game in progress!</p>
                        </div>

                        <!-- Game Overview Table -->
                        <div v-if="gameStats.gameCurrentTurn == 0">
                            <table class="gameStats">
                                <tr>
                                    <td class="gameStat">Game</td>
                                    <td>{{ gameStats.version }}</td>
                                </tr>
                                <tr>
                                    <td class="gameStat">Time Till Start</td>
                                    <td class="countdownTimer">{{ nextTurnCountdown }}</td>
                                </tr>
                                <tr v-if="showTurnButton">
                                    <td></td>
                                    <td v-on:click="turn">
                                        <div class="actionButton">
                                            <p>Turn ⚙️</p>
                                        </div>
                                    </td>
                                </tr>
                            </table>
                        </div>
                        <div v-else>
                            <table class="gameStats">
                                <tr>
                                    <td class="gameStat"><p>Game</p></td>
                                    <td><p>{{ gameStats.version }}</p></td>
                                </tr>
                                <tr>
                                    <td class="gameStat"><p>Number of Players</p></td>
                                    <td><p>{{ gameStats.numberPlayers }}</p></td>
                                </tr>
                                <tr>
                                    <td class="gameStat"><p>Total Gold in the Game</p></td>
                                    <td><p>{{ formatThousands(gameStats.totalGold) }}</p></td>
                                </tr>
                                <tr>
                                    <td class="gameStat"><p>Turns Completed</p></td>
                                    <td><p>{{ isNaN(gameStats.gameCurrentTurn) ? checkingBlockchainString : (gameStats.gameCurrentTurn) }}</p></td>
                                </tr>
                                <tr>
                                    <td class="gameStat"><p>Turns Remaining</p></td>
                                    <td><p>{{ (isNaN(gameStats.gameCurrentTurn) || isNaN(gameStats.gameTurns)) ? checkingBlockchainString : (gameStats.gameTurns - gameStats.gameCurrentTurn) }}</p></td>
                                </tr>
                               <tr>
                                    <td class="gameStat"><p>Turn Time (Hours)</p></td>
                                    <td><p>{{ isNaN(gameStats.gameTurnTimeSeconds) ? checkingBlockchainString : Math.floor(((gameStats.gameTurnTimeSeconds / 60 / 60) * 100)) / 100 }}</p></td>
                                </tr>
                                <tr v-if="gameStats.gameTurns - gameStats.gameCurrentTurn > 0">
                                    <td class="gameStat"><p>Next Turn (Minutes)</p></td>
                                    <td><p>{{ nextTurnCountdown }}</p></td>
                                </tr>
                                <tr>
                                    <td class="gameStat"><p>Winner Prize (Ethereum)</p></td>
                                    <td><p>{{ isNaN(gameStats.totalPrizePool) ? checkingBlockchainString : Math.floor(web3.fromWei(gameStats.totalPrizePool, "ether") * 1000) / 1000 }}</p></td>
                                </tr>
                            </table>
                        </div>

                        <!-- Game Start / End Times -->
                        <p v-if="gameStats.startDate && gameStats.endDate" v-bind:style="topText">The game {{ Number(gameStats.gameCurrentTurn) == 0 ? "will begin" : "began" }} on {{ formatDate(gameStats.startDate) }} and {{ Number(gameStats.gameCurrentTurn) < Number(gameStats.gameTurns) ? "will end" : "ended" }} on {{ formatDate(gameStats.endDate) }}.</p>

                        <div v-if="gameStats.gameCurrentTurn > 0 && (gameStats.gameTurns - gameStats.gameCurrentTurn) > 0" v-bind:style="topText">
                            <p>The kingdom with the most gold on the last turn is the winner and takes the Ethereum prize!</p>
                        </div>

                        <div id="notInGame" v-if="gameStats.gameTurns != checkingBlockchainString && foundAccounts.length > 0 && isInGame != undefined && !isInGame && ((gameStats.gameTurns - gameStats.gameCurrentTurn) != 0)" v-bind:style="notInGameStyle">
                            <p v-bind:style="topText">You're not currently in the game!</p>
                            
                            <div v-if="networkVersion == 3">
                                <p v-bind:style="topText">On the Ropsten test network you can get free test Ethereum from the <a href="https://faucet.ropsten.be" target="_blank" v-bind:class="hyperlink">Ethereum Ropsten Faucet</a> website.</p>
                            </div>

                            <p class="newKingdomName threeSecondTransition" v-bind:style="topText">
                                <strong>New Kingdom Name:</strong>
                                <input autofocus v-model="newPlayerName">
                                <button id="joinGameButton" v-on:click="joinGame"><strong>Join Game</strong></button>
                            </p>

                            <p v-bind:style="topText">It costs {{ Math.ceil((gameValues.gameJoinCostEther + gameValues.gameJoinTransactionCostEther) * 1000) / 1000 }} Ethereum (also called Ether or Eth) to join the game which pays for the prize pool and the game host's fees. Actions within the game have small transaction fees (average cost of {{ gameStats.averageTransactionCost }} Eth, which goes to Ethereum miners). The game will require at most {{ gameStats.gameTurns - 1}} actions to secure a victory, so it will cost <strong>{{ Math.floor((gameValues.gameJoinCostEther + gameValues.gameJoinTransactionCostEther + gameStats.averageTransactionCost * (gameStats.gameTurns - 1)) * 1000) / 1000 }}</strong> Eth to play a full game in total.</p>
                            
                            <div v-if="networkVersion == 3 && (gameStats.gameCurrentTurn == 0 && !isInGame)">
                                <p v-bind:style="topText">You're on the Ropsten test network! Get free test Ethereum from the <a href="https://faucet.ropsten.be:3001" target="_blank" v-bind:class="hyperlink">Ethereum Ropsten Faucet</a>!</p>
                            </div>
                        </div>
                        <div v-else-if="foundAccounts.length > 0 && gameStats.gameCurrentTurn > 0">
                            <table class="playerPanel">
                                <tr>
                                    <td>
                                        
                                        <table id="playerStatsTable" class="playerStats" v-on:click="copyStats">
                                            <tr id="playerStatsTableHeader">
                                                <th>My Kingdom</th>
                                                <th>Stats</th>
                                            </tr>
                                            <tr class="statsInfoButton">
                                                <td>
                                                    <div>
                                                        <p>Name</p>
                                                        <div class="statsInfoPanel">
                                                            <p>What a {{ (randomValue < 0.4) ? "glorious" : (randomValue < 0.7 ? "wonderful" : "magnificant") }} kingdom name you've chosen!</p>
                                                            <p>Kingdom attack power of {{ formatThousands(attackPower) }}.</p>
                                                            <p>Kingdom defence power of {{ formatThousands(defencePower) }}.</p>
                                                        </div>
                                                    </div>
                                                </td>
                                                <td><p>{{ playerStats.kingdomName }}</p></td>
                                            </tr>
                                            <tr class="statsInfoButton">
                                                <td>
                                                    <div>
                                                        <p>Actions</p>
                                                        <div class="statsInfoPanel">
                                                            <p>The number of actions you currently have available to take.</p>
                                                            <p>You receive one action for every turn that passes.</p>
                                                        </div>
                                                    </div>
                                                </td>
                                                <td><p>{{ formatThousands(playerStats.actions) }}</p></td>
                                            </tr>
                                            <tr class="statsInfoButton">
                                                <td>
                                                    <div>
                                                        <p class="goldText">Gold</p>
                                                        <div class="statsInfoPanel">
                                                            <p>The amount of gold in your kingdom.</p>
                                                            <p>Spend gold to improve your kingdom.</p>
                                                            <p>Currently generating <span class="goldText">{{ formatThousands(calculateGoldPerTurn()) }} gold</span> each turn.</p>
                                                        </div>
                                                    </div>
                                                </td>
                                                <td><p class="goldText">{{ formatThousands(playerStats.gold) }}</p></td>
                                            </tr>
                                            <tr class="statsInfoButton">
                                                <td>
                                                    <div>
                                                        <p>Soldiers</p>
                                                        <div class="statsInfoPanel">
                                                            <p>Providing {{ formatThousands(playerStats.soldiers * gameValues.soldierAttack) }} attack power.</p>
                                                        </div>
                                                    </div>
                                                </td>
                                                <td><p>{{ formatThousands(playerStats.soldiers) }}</p></td>
                                            </tr>
                                            <tr class="statsInfoButton">
                                                <td class="spiesCell">
                                                    <div>
                                                        <p>Spies</p>
                                                        <div class="statsInfoPanel">
                                                            <p>Providing {{ formatThousands(playerStats.spies * gameValues.spyAttack) }} attack power.</p>
                                                        </div>
                                                    </div>
                                                </td>
                                                <td class="spiesCell"><p>{{ formatThousands(playerStats.spies) }}</p></td>
                                            </tr>
                                            <tr class="statsInfoButton">
                                                <td>
                                                    <div>
                                                        <p>Wizards</p>
                                                        <div class="statsInfoPanel">
                                                            <p>Providing {{ formatThousands(playerStats.wizards * gameValues.wizardAttack) }} attack power.</p>
                                                            <p>Generating <span class="goldText">{{ formatThousands(playerStats.wizards * gameValues.wizardGoldPerTurn) }}</span> gold each turn.</p>
                                                        </div>
                                                    </div>
                                                </td>
                                                <td><p>{{ formatThousands(playerStats.wizards) }}</p></td>
                                            </tr>
                                            <tr class="statsInfoButton">
                                                <td>
                                                    <div>
                                                        <p>Dragons</p>
                                                        <div class="statsInfoPanel">
                                                            <p>Providing {{ formatThousands(playerStats.dragons * gameValues.dragonAttack) }} attack power.</p>
                                                        </div>
                                                    </div>
                                                </td>
                                                <td><p>{{ formatThousands(playerStats.dragons) }}</p></td>
                                            </tr>
                                            <tr class="statsInfoButton">
                                                <td>
                                                    <div>
                                                        <p>Hovels</p>
                                                        <div class="statsInfoPanel">
                                                            <p>Generating <span class="goldText">{{ formatThousands(playerStats.hovels * gameValues.hovelGoldPerTurn) }} gold</span> each turn.</p>
                                                            <p>Currently hoveling {{ formatThousands(playerStats.spies + playerStats.wizards) }}.</p>
                                                            <p>Hoveling capcity of {{ formatThousands(playerStats.hovels * gameValues.hovelCapacity) }}.</p>
                                                            <p>Hoveling occupancy of {{ Math.ceil((((playerStats.spies + playerStats.wizards) / (playerStats.hovels * gameValues.hovelCapacity)) * 100)) }}%.</p>
                                                        </div>
                                                    </div>
                                                </td>
                                                <td><p>{{ formatThousands(playerStats.hovels) }}</p></td>
                                            </tr>
                                            <tr class="statsInfoButton">
                                                <td>
                                                    <div>
                                                        <p>Mining Camps</p>
                                                        <div class="statsInfoPanel">
                                                            <p>Generating <span class="goldText">{{ formatThousands(playerStats.miningCamps * gameValues.miningCampGoldPerTurn) }} gold</span> each turn.</p>
                                                        </div>
                                                    </div>
                                                </td>
                                                <td><p>{{ formatThousands(playerStats.miningCamps) }}</p></td>
                                            </tr>
                                            <tr class="statsInfoButton">
                                                <td>
                                                    <div>
                                                        <p>Banks</p>
                                                        <div class="statsInfoPanel">
                                                            <p>Generating <span class="goldText">{{ formatThousands(playerStats.banks * Math.floor(playerStats.gold / gameValues.bankedGoldPerUnitGoldPerTurn)) }} gold</span> each turn.</p>
                                                        </div>
                                                    </div>
                                                </td>
                                                <td><p>{{ formatThousands(playerStats.banks) }}</p></td>
                                            </tr>
                                            <tr class="statsInfoButton">
                                                <td>
                                                    <div>
                                                        <p>Barracks</p>
                                                        <div class="statsInfoPanel">
                                                            <p>Providing {{ formatThousands(playerStats.barracks * gameValues.barracksDefence) }} defence power.</p>
                                                            <p>Recruiting {{ formatThousands(playerStats.barracks * gameValues.barracksSoldiersPerTurn) }} soldiers each turn.</p>
                                                        </div>
                                                    </div>
                                                </td>
                                                <td><p>{{ formatThousands(playerStats.barracks) }}</p></td>
                                            </tr>
                                            <tr class="statsInfoButton">
                                                <td>
                                                    <div>
                                                        <p>Castles</p>
                                                        <div class="statsInfoPanel">
                                                            <p>Providing {{ formatThousands(playerStats.castles * gameValues.castleDefence) }} defence power.</p>
                                                            <p>Recruiting {{ formatThousands(playerStats.castles * gameValues.castleSoldiersPerTurn) }} soldiers each turn.</p>
                                                        </div>
                                                    </div>
                                                </td>
                                                <td><p>{{ formatThousands(playerStats.castles) }}</p></td>
                                            </tr>
                                        </table>

                                    </td>
                                    
                                    <td>

                                        <table class="playerActions">
                                            <tr>
                                                <th>Actions</th>
                                            </tr>
                                            <tr>
                                                <td v-on:click="recruitSoldiers">
                                                    <div class="actionButton">
                                                        <p>Recruit Soldiers {{ randomValue < 0.5 ? "💂‍♀️" : "💂‍♀️" }}</p>
                                                        <div class="actionInfoPanel">
                                                            <p>Costs {{ gameValues.soldierCost }} gold each to recruit.</p>
                                                            <p>Provides {{ gameValues.soldierAttack }} attack power each.</p>
                                                            <p>Soldiers are easy to kill.</p>
                                                        </div>
                                                    </div>
                                                </td>
                                            </tr>
                                            <tr>
                                                <td v-on:click="recruitSpies">
                                                    <div class="actionButton">
                                                        <p>Recruit Spies {{ randomValue > 0.5 ? "🕵️‍♂️" : "🕵️‍♀️" }}</p>
                                                        <div class="actionInfoPanel">
                                                            <p>Costs {{ gameValues.spyCost }} gold each to recruit.</p>
                                                            <p>Provides {{ gameValues.spyAttack }} attack power each.</p>
                                                            <p>Spies are impossible to kill.</p>
                                                            <p>Requires a hovel to live in.</p>
                                                            <p>Recruiting spies does not use an action, but you must have at least 1!</p>
                                                        </div>
                                                    </div>
                                                </td>
                                            </tr>
                                            <tr>
                                                <td v-on:click="summonWizards">
                                                    <div class="actionButton">
                                                        <p>Summon Wizards {{ randomValue < 0.5 ? "🧙‍♂️" : "🧙‍♀️" }}</p>
                                                        <div class="actionInfoPanel">
                                                            <p>Costs {{ gameValues.wizardCost }} gold to summon.</p>
                                                            <p>Provides {{ gameValues.wizardAttack }} attack power.</p>
                                                            <p>Generates {{ gameValues.wizardGoldPerTurn }} gold each turn.</p>
                                                            <p>Wizards are hard to kill.</p>
                                                            <p>Requires a hovel to live in.</p>
                                                        </div>
                                                    </div>
                                                </td>
                                            </tr>
                                            <tr>
                                                <td v-on:click="trainDragons">
                                                    <div class="actionButton">
                                                        <p>Train Dragons 🐲</p>
                                                        <div class="actionInfoPanel">
                                                            <p>Costs {{ formatThousands(gameValues.dragonCost) }} gold to train. (Training is instantaneous!)</p>
                                                            <p>Provides {{ gameValues.dragonAttack }} attack power.</p>
                                                            <p>Dragons are very hard to kill.</p>
                                                        </div>
                                                    </div>
                                                </td>
                                            </tr>
                                            <tr>    
                                                <td v-on:click="buildHovels">
                                                    <div class="actionButton">
                                                        <p>Build Hovels 🏠</p>
                                                        <div class="actionInfoPanel">
                                                            <p>Costs {{ gameValues.hovelCost }} gold to build.</p>
                                                            <p>Generates {{ gameValues.hovelGoldPerTurn }} gold each turn.</p>
                                                            <p>Houses {{ gameValues.hovelCapacity }} spies or wizards.</p>
                                                        </div>
                                                    </div>
                                                </td>
                                            </tr>
                                            <tr>
                                                <td v-on:click="buildMiningCamps">
                                                    <div class="actionButton">
                                                        <p>Build Mining Camps ⛺️</p>
                                                        <div class="actionInfoPanel">
                                                            <p>Costs {{ formatThousands(gameValues.miningCampCost) }} gold to build.</p>
                                                            <p>Generates {{ gameValues.miningCampGoldPerTurn }} gold each turn.</p>
                                                        </div>
                                                    </div>
                                                </td>
                                            </tr>
                                            <tr>
                                                <td v-on:click="buildBanks">
                                                    <div class="actionButton">
                                                        <p>Build Banks 🏛</p>
                                                        <div class="actionInfoPanel">
                                                            <p>Costs {{ formatThousands(gameValues.bankCost) }} gold to build.</p>
                                                            <p>Generates 1 gold for every {{ formatThousands(gameValues.bankedGoldPerUnitGoldPerTurn) }} gold in the kingdom each turn.</p>
                                                            <p>Interest rate of {{ 100 / gameValues.bankedGoldPerUnitGoldPerTurn }}% per bank.</p>
                                                            <p>Limit of {{ formatThousands(gameValues.bankLimit) }} banks per kingdom.</p>
                                                        </div>
                                                    </div>
                                                </td>
                                            </tr>
                                            <tr>
                                                <td v-on:click="buildBarracks">
                                                    <div class="actionButton">
                                                        <p>Build Barracks 🏢</p>
                                                        <div class="actionInfoPanel">
                                                            <p>Costs {{ gameValues.barracksCost }} gold to build.</p>
                                                            <p>Recruits {{ gameValues.barracksSoldiersPerTurn }} soldiers each turn.</p>
                                                            <p>Provides {{ gameValues.barracksDefence }} defence power.</p>
                                                        </div>
                                                    </div>
                                                </td>
                                            </tr>
                                            <tr>
                                                <td v-on:click="buildCastles">
                                                    <div class="actionButton">
                                                        <p>Build Castles 🏰</p>
                                                        <div class="actionInfoPanel">
                                                            <p>Costs {{ formatThousands(gameValues.castleCost) }} gold to build.</p>
                                                            <p>Recruits {{ formatThousands(gameValues.castleSoldiersPerTurn) }} soldiers each turn.</p>
                                                            <p>Provides {{ formatThousands(gameValues.castleDefence) }} defence power.</p>
                                                            <p>Castles cannot be destroyed.</p>
                                                        </div>
                                                    </div>
                                                </td>
                                            </tr>
                                            <tr>
                                                <td v-on:click="attack">
                                                    <div class="attackButton">
                                                        <p>Attack ⚔️</p>
                                                        <div v-bind:style="tooltip" class="attackInfoPanel">
                                                            <p>Send in your army to attack another player's kingdom and try to steal some of their gold!</p>
                                                            <p>⚔️</p>
                                                            <p>An attack power is calculated based on the amount of soldiers you choose to send plus the number of spies, wizards, and dragons in your kingdom.</p>
                                                            <p>A defence power is calculated for the defending kingdom as the attack power for its army plus the defence power of its barracks and castles.</p>
                                                            <p>If your attack power is greater than your opponent's defence power, you will win the attack and take a fraction of your opponent's gold!</p>
                                                            <img id="icon" src="./coinbag.png" alt="Coin Bag">
                                                            <p>Soldiers, wizards, and dragons may be lost on both sides during the battle. Only the attacker's losses are reported in the public event log.</p>
                                                            <p>💀</p>
                                                            <p>(Gold taken is proportional to the closeness of the battle. If the battle is close, huge casualties and large portions of gold may be taken.)</p>                                                           
                                                        </div>
                                                    </div>
                                                </td>
                                            </tr>
                                            <tr>
                                                <td v-on:click="espionage">
                                                    <div class="espionageButton">
                                                        <p>Espionage 🔎</p>
                                                        <div v-bind:style="tooltip" class="espionageInfoPanel">
                                                            <p>Costs {{ formatThousands(gameValues.espionageCost) }} gold.</p>
                                                            <p>Contract your spies to discover information about another player's kingdom!</p>
                                                            <p>👀</p>
                                                            <p>If you have more than half the number of spies your opponent has, everyone will receive a piece of information about your opponent's kingdom in the public event log.</p>
                                                            <p>Using espionage does not use an action, but you must have at least 1!</p>
                                                        </div>
                                                    </div>
                                                </td>
                                            </tr>
                                            <tr>
                                                <td v-on:click="sabotage">
                                                    <div class="sabotageButton">
                                                        <p>Sabotage 🔥</p>
                                                        <div v-bind:style="tooltip" class="sabotageInfoPanel">
                                                            <p>Send in your trained dragons to destroy a fraction of an enemy's kingdom!</p>
                                                            <p>🐲</p>
                                                            <p>If you have more dragons than your opponent has castles plus dragons, some of your opponent's mining camps, banks, and hovels may be burned to the ground.</p>
                                                            <p>Dragons may be lost on both sides during a sabotage.</p>
                                                        </div>
                                                    </div>
                                                </td>
                                            </tr>
                                            <tr v-if="showTurnButton">
                                                <td v-on:click="message">
                                                    <div id="messageButton" class="actionButton">
                                                        <p>Message ✉️</p>
                                                    </div>
                                                </td>
                                            </tr>
                                            <tr v-if="showTurnButton">
                                                <td v-on:click="turn">
                                                    <div class="actionButton">
                                                        <p>Turn ⚙️</p>
                                                    </div>
                                                </td>
                                            </tr>
                                        </table>

                                    </td>
                                    <td>

                                        <table class="playerListing">
                                            <tr>
                                                <th id="listOfKingdomsHeader">List of Kingdoms{{ kingdomListType }}</th>
                                            </tr>
                                            <tr v-for="playerIndex in players.length">
                                                <td v-on:click="kingdomSelected(playerIndex)">
                                                    <p>{{ players[playerIndex - 1] }}</p>
                                                    <div id="leaderCrown" v-if="(playerIndex - 1) == gameStats.leaderPlayerIndex">
                                                        <p>👑</p>
                                                        <div id="leaderCrownInfoPanel">
                                                            <p>The crown indicates the current game leader as of the start of the current turn.</p>
                                                            <p>The crown may move when the next turn passes!</p>
                                                        </div>
                                                    </div>
                                                </td>
                                            </tr>
                                        </table>

                                    </td>
                                </tr>
                            </table>

                            <p class="playerListingDesktopTip" v-bind:style="bottomText">Hover over stats and actions to see details.</p>
                            <p class="playerListingMobileTip" v-bind:style="bottomText">Tap on stats to bring up details.</p>
                            <p class="playerListingMobileTip" v-bind:style="bottomText">Tap on the background to hide details.</p>
                            <p class="playerListingMobileTip" v-bind:style="bottomText">Tap on actions to use them <strong>and</strong> bring up their details.</p>
                            <p class="playerListingMobileRotateTip" v-bind:style="bottomText">You are on a small display! Rotate your phone to see the list of kingdoms!</p>
                        </div>

                        <div id="waitingMessage" v-if="waitingForActionTransactionMessage.length > 0">
                            <p id="waitingMessageText" v-bind:style="bottomText"><strong>{{ waitingForActionTransactionMessage }}</strong></p>
                            <img id="waitingSpinner" src="spinner.gif" alt="Spinner">
                        </div>

                        <div id="publicEventLog" class="eventLog fadeInSlow" v-if="isInGame && gameStats.gameCurrentTurn > 0">
                            <p class="eventLogTitle" v-bind:style="bottomText"><strong>Public Event Log</strong></p>
                            <div class="eventMessageBox">
                                <table class="eventMessages">
                                    <tr v-for="eventMessage in eventMessages">
                                        <td width="30%"><p><strong>{{ eventMessage.time }}</strong></p></td>
                                        <td><p><strong>{{ eventMessage.text }}</strong></p></td>
                                    </tr>
                                </table>
                            </div>
                        </div>

                        <div v-if="gameStats.gameCurrentTurn == 0 && isInGame" v-bind:style="bottomText">
                            <div class="signedUp">
                                <p><strong>You're signed up and ready for the game to start! Come back later!</strong></p>
                                <p><strong>🏰</strong></p>
                            </div>
                        </div>

                        <div v-if="gameStats.gameCurrentTurn != checkingBlockchainString && gameStats.gameCurrentTurn == gameStats.gameTurns">
                            <p>The game ended on {{ formatDate(gameStats.endDate) }}. Congratulations to <strong>{{ winnerStats.kingdomName }}</strong> who was the winner with <strong>{{ formatThousands(winnerStats.gold) }}</strong> gold!</p>
                            <table class="winnerStats">
                                <tr>
                                    <th><p>Winning Kingdom</p></th>
                                    <th><p>Stats</p></th>
                                </tr>
                                <tr>
                                    <td><div class="statsInfoButton"><p>Name</p></div></td>
                                    <td><p>{{ winnerStats.kingdomName }} 👑</p></td>
                                </tr>
                                <tr>
                                    <td><div class="statsInfoButton"><p>Actions</p></div></td>
                                    <td><p>{{ formatThousands(winnerStats.actions) }}</p></td>
                                </tr>
                                <tr>
                                    <td><div class="statsInfoButton"><p>Gold</p></div></td>
                                    <td><p>{{ formatThousands(winnerStats.gold) }}</p></td>
                                </tr>
                                <tr>
                                    <td><div class="statsInfoButton"><p>Soldiers</p></div></td>
                                    <td><p>{{ formatThousands(winnerStats.soldiers) }}</p></td>
                                </tr>
                                <tr>
                                    <td><div class="statsInfoButton"><p>Spies</p></div></td>
                                    <td><p>{{ formatThousands(winnerStats.spies) }}</p></td>
                                </tr>
                                <tr>
                                    <td><div class="statsInfoButton"><p>Wizards</p></div></td>
                                    <td><p>{{ formatThousands(winnerStats.wizards) }}</p></td>
                                </tr>
                                <tr>
                                    <td><div class="statsInfoButton"><p>Dragons</p></div></td>
                                    <td><p>{{ formatThousands(winnerStats.dragons) }}</p></td>
                                </tr>
                                <tr>
                                    <td><div class="statsInfoButton"><p>Hovels</p></div></td>
                                    <td><p>{{ formatThousands(winnerStats.hovels) }}</p></td>
                                </tr>
                                <tr>
                                    <td><div class="statsInfoButton"><p>Mining Camps</p></div></td>
                                    <td><p>{{ formatThousands(winnerStats.miningCamps) }}</p></td>
                                </tr>
                                <tr>
                                    <td><div class="statsInfoButton"><p>Banks</p></div></td>
                                    <td><p>{{ formatThousands(winnerStats.banks) }}</p></td>
                                </tr>
                                <tr>
                                    <td><div class="statsInfoButton"><p>Barracks</p></div></td>
                                    <td><p>{{ formatThousands(winnerStats.barracks) }}</p></td>
                                </tr>
                                <tr>
                                    <td><div class="statsInfoButton"><p>Castles</p></div></td>
                                    <td><p>{{ formatThousands(winnerStats.castles) }}</p></td>
                                </tr>
                            </table>
                            <p v-bind:style="topText">Thank you for playing Crypto Kingdoms!</p>
                            <p>🏰</p>
                            <br>
                        </div>
                        
                        <p v-bind:style="bottomText">Please see the <a href="https://github.com/CryptoKingdoms/Game8" target="_blank" v-bind:style="hyperlink">README.md</a> for an overview of the game. Crypto Kingdoms is open source. Source code is available for the <a href="https://etherscan.io/address/0x89f4d59797199b84447f8a2f7eceb0bef962a9d6#code" target="_blank" v-bind:style="hyperlink">Ethereum Solidity Smart Contract</a> and this website client is self-contained.</p>

                        <div v-if="networkVersion == 3 && foundAccounts.length > 0 && foundAccounts[0].balance == 0">
                            <p>You have no Ethereum! You can get free test Ethereum from the <a href="https://faucet.ropsten.be:3001" target="_blank" v-bind:style="hyperlink">Ethereum Ropsten Faucet</a>!</p>
                        </div>
                            <div v-else-if="networkVersion == 3 && foundAccounts.length > 0 && foundAccounts[0].balance < 0.1">
                                <p>You're running low on Ethereum! You can get free test Ethereum from the <a href="https://faucet.ropsten.be:3001" target="_blank" v-bind:style="hyperlink">Ethereum Ropsten Faucet</a>!</p>
                            </div> 
                        </div>
                    </div>

                    <div>
                        <p v-bind:style="bottomText">{{ helpText }} <a href="mailto:admin@cryptokingdoms.org" target="_top" v-bind:style="hyperlink">admin@cryptokingdoms.org</a></p>
                        <p v-bind:style="bottomText">CryptoKingdoms.org does not collect or store any information.<span v-if="gameStats.gameCurrentTurn > (gameStats.gameTurns * 7 / 10) && gameStats.gameCurrentTurn < (gameStats.gameTurns * 8 / 10) "> No cookies. Nothing.</span></p>
                    </div>

                    <!-- Space for fixed position networkStatus div box. -->
                    <br><br><br><br><br><br>

                    <div class="hidden" v-bind:class="{ networkStatus : (gameStats.version > 0) }">
                        <div id= "armyUnits" class="unitPlatform unselectable">
                        </div>
                        <div v-if="foundAccounts.length == 0" class="noAccountsSection">
                            <p class="unlockMetaMask">No Ethereum accounts found.</p>
                            <div v-if="web3.currentProvider.isMetaMask === true">
                                <p class="unlockMetaMask">Do you need to unlock MetaMask?</p>
                            </div>
                            <div v-else>
                                <p class="unlockMetaMask">Do you need to unlock your Ethereum account?</p>
                            </div>
                            <p class="unlockMetaMask"><a v-bind:href="window.location.href">Click to refresh the page.</a></p>
                        </div>
                        <div v-else class="accountInfoSection">
                            <table class="accountInfo">
                                <tr>
                                    <th id="account.balance" v-on:click="balanceSelected(account.address)">{{ "My " + (foundAccounts.length <= 1 ? "Account" : "Accounts") }}</th>
                                    <th>Balance</th>
                                </tr>
                                <tr v-for="account in foundAccounts">
                                    <td id="account.address" v-on:click="addressSelected(account.address)">{{ account.address }}</td>
                                    <td v-on:click="balanceSelected(account.balance)">{{ account.balance }}</td>
                                </tr>
                            </table>
                            <div v-if="web3.isConnected()">
                                <p class="networkConnection">Connected to Ethereum {{ networkName }} network.</p>
                            </div>
                            <div>
                                <p class="time">{{ lastUpdateTime.toLocaleString() }}</p>
                            </div>
                        </div>
                    </div>
                </div>

            </div> 

        </div>
        
        <script>

            // Global Values

            gameValues = {}

            gameValues.gameJoinCostEther = 0.0225

            gameValues.soldierCost = 3
            gameValues.spyCost = 100
            gameValues.wizardCost = 250
            gameValues.dragonCost = 3000
            gameValues.hovelCost = 100
            gameValues.miningCampCost = 1000
            gameValues.bankCost = 1500
            gameValues.barracksCost = 300
            gameValues.castleCost = 15000

            gameValues.soldierAttack = 1
            gameValues.spyAttack = 5
            gameValues.wizardAttack = 100
            gameValues.dragonAttack = 500

            gameValues.barracksDefence = 5
            gameValues.castleDefence = 1000

            gameValues.wizardGoldPerTurn = 20
            gameValues.hovelGoldPerTurn = 5
            gameValues.miningCampGoldPerTurn = 150

            gameValues.bankedGoldPerUnitGoldPerTurn = 50
            gameValues.bankLimit = 15

            gameValues.barracksSoldiersPerTurn = 25
            gameValues.castleSoldiersPerTurn = 50

            gameValues.hovelCapacity = 3

            gameValues.espionageCost = 25

            gameValues.startingNumberHovels = 3
            gameValues.startingNumberMiningCamps = 1

            gameValues.gameJoinTransactionCostEther = 0.0025

            gameStatsKeys = [ "version", "numberPlayers", "totalGold", "totalPrizePool",
                              "gameStartTimeSeconds", "gameDurationSeconds",
                              "gameTurns", "gameTurnTimeSeconds", "gameCurrentTurn",
                              "leaderPlayerIndex" ]

            playerStatsKeys = [ "race", "kingdomName", "actions", "gold",
                                "soldiers", "spies", "wizards", "dragons",
                                "hovels", "miningCamps", "banks", "barracks", "castles" ]
            
            noActionsText = "You don't currently have any available actions."

            defaultGas = 100000

            // Background Experiments

            const SkyShade = {
                gradient: "gradient",
                lionize: "lionize",
                normal: "normal",
                sunset: "sunset",
                gold: "gold"
            }

            var skyShade = SkyShade.normal
            if (window.location.href.includes("bling")) {
                skyShade = "gold"
            }

            var skyImage = "none"
            var skyColor = "aliceblue"
            var topTextColor = "black"
            var bottomTextColor = "black"
            var hyperlinkColor = "#0000EE"

            switch (skyShade) {
                case SkyShade.gradient: skyImage = "linear-gradient(black, darkblue, blue, skyblue, lightblue, aliceblue, white)"
                                        hyperlinkColor = "#b9b9ff"
                                        topTextColor = "#e2e2e2"; break
                case SkyShade.lionize: skyImage = "linear-gradient(red, yellow, blue)"
                                       bottomTextColor = "white"; break
                case SkyShade.normal: skyImage = "none"; break
                case SkyShade.sunset: skyImage = "none"; break
                case SkyShade.gold: skyImage = "none"; skyColor = "black"; bottomTextColor = topTextColor = "gold"; hyperlinkColor = "white"; break
            }

            // Crypto Kingdoms Vue.js Web App

            log("Vue.js API " + Vue.version)

            app = new Vue({

                el: "#CryptoKingdoms",

                data: {
                    attackPower: 0,
                    bodyBackground: { backgroundColor: skyColor, backgroundImage: skyImage },
                    bottomText: { "color" : bottomTextColor, "a:hover" : hyperlinkColor },
                    checkingBlockchain: {},
                    checkingBlockchainString: "Syncing...",
                    defencePower: 0,
                    disableFont: window.location.href.includes("font"),
                    eventMessage: "",
                    eventMessages: [],
                    foundAccounts: [],
                    gameStats: { "averageTransactionCost" : 0.00015, "numberPlayers" : 0 },
                    gameValues: gameValues,
                    goldPerTurn: 0,
                    hasEthereum: hasEthereum,
                    helpText: "If you need any help, would like to send feedback, or to sign up to the mailing list - please email!",
                    hyperlink: { "color" : hyperlinkColor },
                    isInGame: false,
                    kingdomListType: "",
                    kingdomSelectionType: "none",
                    lastUpdateTime: new Date(),
                    netWorth: 0,
                    networkVersion: "Unknown",
                    newPlayerName: undefined,
                    nextTurnCountdown: "",
                    notInGameStyle: {},
                    numberAttackingSoldiers: 0,
                    latestCasualties: [0, 0, 0, 0],
                    playerStats: {},
                    players: [],
                    previousAnimateArmyUnitsArgs: { "direction" : null,
                                                    "numberOfSoldiers" : 0, "numberOfSpies" : 0, "numberOfWizards" : 0, "numberOfDragons" : 0 },
                    randomValue: Math.random(),
                    showTurnButton: window.location.href.includes("turn"),
                    soldiersPerTurn: 0,
                    title: { "color" : topTextColor },
                    tips: [ "Crypto Kingdoms is a slow-paced game, plan and time your moves.",
                            "Type \"Font\" into the URL bar to switch the font to a more regular font.",
                            "You can see previous games by going to /game/<game_number>. For example, to see game 6, go to www.cryptokingdoms.org/game/6. Games 1-7 were run on the Ropsten test network. Game 1 is lost!",
                            "Conflicts are always worse when they are close.",
                            "It is intentionally hard to remember when an action is available to give all players a chance to take actions.",
                            "Crypto Kingdoms is a slow-placed game to keep it fair and balanced.",
                            "Don't worry if you miss a few days during the game, just don't miss the whole thing!",
                            "Sometimes you need to manually \"EDIT\" a transaction fee when making an action (in the transaction window that appears). If the transaction fee is set to 0 the transaction will fail!" ],
                    tipsFirstHalf: [ "Don't forget to come back!" ],
                    tipsSecondHalf: [ "" ],
                    tooltip: {},
                    topText: { "color" : topTextColor },
                    waitingForActionTransactionMessage: "",
                    web3: web3,
                    winnerStats: {}
                },

                created: function() {
                    gameStatsKeys.forEach((gameStatKey, i) => this.gameStats[gameStatKey] = this.checkingBlockchainString)
                },

                computed: {
                    networkName() {
                        ethereumNetworkName = "unknown"
                        if (web3)
                        {
                            networkVersion = app.networkVersion
                            switch (networkVersion) {
                                case "1": ethereumNetworkName = "Mainnet"; break;
                                case "2": ethereumNetworkName = "Morden (deprecated) test"; break;
                                case "3": ethereumNetworkName = "Ropsten test"; break;
                                case "4": ethereumNetworkName = "Rinkeby test"; break;
                                case "42": ethereumNetworkName = "Kovan test"; break;
                                default: ethereumNetworkName = "Unknown (" + networkVersion + ")|"; break;
                            }
                        }
                        return ethereumNetworkName
                    }
                },

                methods: {
                    sleep(timeMilliseconds) {
                        return new Promise(resolve => setTimeout(resolve, timeMilliseconds));
                    },
                    async transactionReceiptPoll(transactionHash, transactionReceiptRecievedCallback) {
                        app.bodyBackground.backgroundColor = "white"
                        app.bodyBackground.backgroundImage = "none"

                        transactionReceipt = undefined
                        while (transactionReceipt == undefined) {
                            web3.eth.getTransactionReceipt(transactionHash, function(error, result) {
                                transactionReceipt = result
                            })
                            await app.sleep(5000)
                        }
                        status = Number(transactionReceipt.status)

                        log("Transaction " + transactionHash + " completed " + (status == 0 ? "unsuccessfully ❌" : "successfully ✅"))
                        log(transactionReceipt)

                        app.updateAccountInfo()

                        app.bodyBackground.backgroundColor = skyColor
                        app.bodyBackground.backgroundImage = skyImage
                        app.waitingForActionTransactionMessage = ""

                        if (status != 0)
                        {
                            transactionReceiptRecievedCallback()
                        }
                    },
                    setWaitingMessage(type) {
                        app.waitingForActionTransactionMessage = "Waiting for " + type + " transaction to complete..."
                        var eventMessageBox = document.getElementById("publicEventLog")
                        if (eventMessageBox) {
                            eventMessageBox.scrollIntoView({ block: "start", behavior: "smooth" })
                        }
                        else {
                            var waitingMessage = document.getElementById("waitingMessage")
                            if (waitingMessage) {
                                waitingMessage.scrollIntoView({ block: "start", behavior: "smooth" })
                            }
                        }
                    },
                    formatDate(date) {
                        if (date == undefined) {
                            return "Unknown"
                        }
                        hours = (date.getHours() == 12) ? 12 : (date.getHours() % 12)
                        minutes = date.getMinutes()
                        amPm = (date.getHours() < 12) ? "am" : "pm"
                        isInTheMiddleOfTheNight = (date.getHours() == 0 || date.getHours() == 1 || date.getHours() == 2)
                        if (isInTheMiddleOfTheNight) {
                            date.setDate(date.getDate() - 1)
                        }
                        switch (date.getMonth()) {
                            case 0: month = "January"; break;
                            case 1: month = "February"; break;
                            case 2: month = "March"; break;
                            case 3: month = "April"; break;
                            case 4: month = "May"; break;
                            case 5: month = "June"; break;
                            case 6: month = "July"; break;
                            case 7: month = "August"; break;
                            case 8: month = "September"; break;
                            case 9: month = "October"; break;
                            case 10: month = "November"; break;
                            case 11: month = "December"; break;
                        }
                        switch (date.getDay()) {
                            case 0: weekday = "Sunday"; break;
                            case 1: weekday = "Monday"; break;
                            case 2: weekday = "Tuesday"; break;
                            case 3: weekday = "Wednesday"; break;
                            case 4: weekday = "Thursday"; break;
                            case 5: weekday = "Friday"; break;
                            case 6: weekday = "Saturday"; break;
                        }
                        day = date.getDate()
                        if (day == 1 || day == 21) day += "st"
                        else if (day == 2 || day == 22) day += "nd"
                        else if (day == 3 || day == 23) day += "rd"
                        else day += "th"
                        formattedDateString = weekday + " " + day + " " + month
                        if (isInTheMiddleOfTheNight) {
                            formattedDateString += " in the middle of the night"
                        }
                        else {
                            formattedDateString += " at " + hours + ":" + (minutes < 10 ? "0" + minutes : minutes) + amPm
                        }
                        return formattedDateString
                    },
                    formatDateForLog(date) {
                        hours = (date.getHours() == 12) ? 12 : (date.getHours() % 12)
                        minutes = date.getMinutes()
                        amPm = (date.getHours() < 12) ? "am" : "pm"
                        month = date.getMonth()
                        day = date.getDay()
                        date = date.getDate()
                        formattedDateString = month + "/" + date + " "
                        formattedDateString += hours + ":" + (minutes < 10 ? "0" + minutes : minutes) + amPm
                        return formattedDateString
                    },
                    formatThousands(n) {
                        return String(n).replace(/\B(?=(\d{3})+(?!\d))/g, ",")
                    },
                    formatEnglishNumber(number, shouldCapitalize = false) {
                        w = ""
                        switch (number) {
                            case 0: w = "zero"; break;
                            case 1: w = "one"; break;
                            case 2: w = "two"; break;
                            case 3: w = "three"; break;
                            case 4: w = "four"; break;
                            case 5: w = "five"; break;
                            case 6: w = "six"; break;
                            case 7: w = "seven"; break;
                            case 8: w = "eight"; break;
                            case 9: w = "nine"; break;
                            case 10: w = "ten"; break;
                            case 11: w = "eleven"; break;
                            case 12: w = "twelve"; break;
                            default: return app.formatThousands(number)
                        }
                        if (shouldCapitalize) w = w.charAt(0).toUpperCase() + w.slice(1)
                        return w
                    },
                    updateAccountInfo() {
                        web3.eth.getAccounts(function(error, accounts) {
                            for (accountIndex in accounts)
                            {
                                web3.eth.getBalance(accounts[accountIndex], 'latest', function(error, result) {
                                    if (error) {
                                        log("getAccounts error", error)
                                    }
                                    else {
                                        etherBalance = web3.fromWei(result.toString(), "ether")
                                        foundExisitingAccount = false
                                        for (existingAccountIndex in app.foundAccounts) {
                                            if (app.foundAccounts[existingAccountIndex]["address"] == accounts[accountIndex]) {
                                                foundExisitingAccount = true
                                                app.foundAccounts[existingAccountIndex]["balance"] = etherBalance
                                                break
                                            }
                                            existingAccountIndex += 1
                                        }
                                        if (!foundExisitingAccount) {
                                            app.foundAccounts.push({
                                                "address" : accounts[accountIndex],
                                                "balance" : etherBalance
                                            })
                                        }
                                    }
                                })
                            }
                        })
                    },
                    updateGameStats() {
                        if (app.checkingBlockchain["updateGameStats"] !== true) {
                            app.checkingBlockchain["updateGameStats"] = true
                            cryptoKingdoms.gameStats(function(error, gameStats) {
                                                         app.checkingBlockchain["updateGameStats"] = false
                                                         if (error) {
                                                             log("updateGameStats error", error)
                                                         }
                                                         else
                                                         {
                                                             gameStatsKeys.forEach((gameStatKey, i) => {
                                                                 Vue.set(app.gameStats, gameStatKey, Number(gameStats[i]))
                                                             })
                                                             Vue.set(app.gameStats, "startDate", new Date(app.gameStats.gameStartTimeSeconds * 1000))
                                                             Vue.set(app.gameStats, "endDate", new Date((Number(app.gameStats.gameStartTimeSeconds)
                                                                                                        + Number(app.gameStats.gameDurationSeconds)) * 1000))

                                                             app.updateListOfPlayers()
                                                             app.updateNextTurnTime()
                                                         }
                                                     })
                        }

                        const getJSON = async url => {
                            try {
                                const response = await fetch(url)
                                if (!response.ok) {
                                    throw new Error(response.statusText)
                                }
                                const data = await response.json()
                                return data
                            }
                            catch(error) {
                                return error;
                            }
                        }

                        // var etherscanAPIKey = "FXSZ6QG3AFX91NTUCYSRWHYVJYP8CI9FFW"
                        // var transactionsRequest = "https://api.etherscan.io/api?module=account&action=txlist&address=" + cryptoKingdomsContractAddress
                        // transactionsRequest += "&apikey=" + etherscanAPIKey
                        // console.log("Making request to " + transactionsRequest + " for transactions...")
                        // getJSON(transactionsRequest).then(data => {
                        //     console.log(data.result)
                        // }).catch(error => {
                        //     console.error(error)
                        // });
                    },
                    updateNextTurnTime() {
                        var isWaitingForGameToStart = app.gameStats.gameCurrentTurn == 0
                        if (isWaitingForGameToStart) {
                            var nextTurnDate = new Date(app.gameStats.gameStartTimeSeconds * 1000)                                        
                        }
                        else {
                            var gameEndTime = app.gameStats.gameStartTimeSeconds + app.gameStats.gameDurationSeconds
                            var turnsRemaining = app.gameStats.gameTurns - app.gameStats.gameCurrentTurn - 1
                            var nextTurnDate = new Date((gameEndTime - (turnsRemaining * app.gameStats.gameTurnTimeSeconds)) * 1000)
                        }
                        var now = new Date().getTime()
                        var timeUntilNextTurn = nextTurnDate - now + 60
                        if (timeUntilNextTurn < 1) {
                            app.nextTurnCountdown = "Waiting for network to process turn..."
                        }
                        else {  
                            var days = Math.floor(timeUntilNextTurn / (1000 * 60 * 60 * 24))
                            var hours = Math.floor((timeUntilNextTurn % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60))
                            var minutes = Math.floor((timeUntilNextTurn % (1000 * 60 * 60)) / (1000 * 60))
                            var seconds = Math.floor((timeUntilNextTurn % (1000 * 60)) / 1000)
                            app.nextTurnCountdown = app.formatNextTurnTime(true, days, hours, minutes, seconds)
                        }
                    },
                    formatNextTurnTime(useWords, days, hours, minutes, seconds) {
                        formattedTime = ""
                        if (app.gameStats.gameCurrentTurn != 0)
                        {
                            formattedTime += hours * 60 + minutes
                        }
                        else
                        {
                            if (useWords)
                            {
                                if (days > 0) {
                                    formattedTime += days + " day"
                                    if (days > 1) formattedTime += "s"
                                }
                                if (hours > 0) {
                                    if (days > 0) formattedTime += ", "
                                    formattedTime += hours + " hour"
                                    if (hours != 1) formattedTime += "s"
                                }
                                if (minutes > 0) {
                                    if (days > 0 || hours > 0) formattedTime += ", "
                                    formattedTime += minutes
                                    formattedTime += " minute"
                                    if (minutes != 1) formattedTime += "s"
                                }
                                if (seconds > 0 && app.gameStats.gameCurrentTurn == 0) {
                                    if (days > 0 || hours > 0 || minutes > 0) formattedTime += ", "
                                    formattedTime += seconds + " second"
                                    if (seconds > 1) formattedTime += "s"
                                }
                            }
                            else
                            {
                                let padNumber = number => number <= 99 ? `0${number}`.slice(-2) : number;
                                if (days > 0) formattedTime += padNumber(days) + ":"
                                formattedTime += padNumber(hours) + ":" + padNumber(minutes) + ":" + padNumber(seconds)
                            }
                        }
                        return formattedTime
                    },
                    updatePlayerStats(tryAgain = true) {
                        if (app.checkingBlockchain["updatePlayerStats"] !== true || tryAgain === true) {
                            app.checkingBlockchain["updatePlayerStats"] = true
                            cryptoKingdoms.playerStats(function(error, playerStats) {
                                                           app.checkingBlockchain["updatePlayerStats"] = false
                                                           if (error) {
                                                               log("updatePlayerStats error", error)
                                                           }
                                                           else
                                                           {
                                                               playerStatsKeys.forEach((playerStatsKey, i) => {
                                                                   if (playerStatsKey == "kingdomName") {
                                                                       Vue.set(app.playerStats, playerStatsKey, playerStats[i].toString())
                                                                   } else {
                                                                       Vue.set(app.playerStats, playerStatsKey, Number(playerStats[i]))
                                                                   }
                                                               })
                                                               app.isInGame = app.playerStats["race"] != 0

                                                               app.calculateAttackPower()
                                                               app.calculateDefencePower()
                                                               app.calculateNetWorth()
                                                               app.calculateGoldPerTurn()
                                                               app.calculateSoldiersPerTurn()
                                                               
                                                               // Workaround: Sometimes updatePlayerStats doesn't update for a several seconds.
                                                               async function tryUpdateAgain(sleepPeriod) {
                                                                   await app.sleep(sleepPeriod)
                                                                   app.updatePlayerStats(false)
                                                               }
                                                               if (tryAgain) {
                                                                   tryUpdateAgain(5000)
                                                                   tryUpdateAgain(10000)
                                                                   tryUpdateAgain(20000)
                                                                   tryUpdateAgain(30000)
                                                                   tryUpdateAgain(60000)
                                                               }
                                                           }
                                                       })
                        }
                    },
                    updateListOfPlayers() {
                        app.players = []
                        while (app.players.length < app.gameStats.numberPlayers)
                        {
                            app.players.push(app.checkingBlockchainString)
                        }
                        for (i = 0; i < app.gameStats.numberPlayers; i++)
                        {
                            let playerIndex = i
                            cryptoKingdoms.playerAtIndex(playerIndex, function(error, playerName) {
                                                                          Vue.set(app.players, playerIndex, playerName)
                                                                      })
                        }
                    },
                    updateWinnerStats() {
                        playerStatsKeys.forEach((playerStatKey, i) => app.winnerStats[playerStatKey] = app.checkingBlockchainString)
                        cryptoKingdoms.winner(function(error, winnerStats) {
                            if (error) {
                                log("updateWinnerStats error", error)
                            }
                            else
                            {
                                playerStatsKeys.forEach((playerStatsKey, i) => {
                                    if (playerStatsKey == "kingdomName") {
                                        app.winnerStats[playerStatsKey] = winnerStats[i].toString()
                                    } else {
                                       app.winnerStats[playerStatsKey] = Number(winnerStats[i])
                                    }
                                })
                            }
                        })
                    },
                    calculateAttackPower() {
                        app.attackPower = 0
                        if (app.isInGame) {
                            app.attackPower += app.playerStats.soldiers * gameValues.soldierAttack
                                             + app.playerStats.spies    * gameValues.spyAttack
                                             + app.playerStats.wizards  * gameValues.wizardAttack
                                             + app.playerStats.dragons  * gameValues.dragonAttack
                        }
                        return app.attackPower
                    },
                    calculateDefencePower() {
                        app.defencePower = 0
                        if (app.isInGame) {
                            app.defencePower += app.playerStats.soldiers    * gameValues.soldierAttack
                                              + app.playerStats.spies       * gameValues.spyAttack
                                              + app.playerStats.wizards     * gameValues.wizardAttack
                                              + app.playerStats.dragons     * gameValues.dragonAttack
                                              + app.playerStats.barracks    * gameValues.barracksDefence
                                              + app.playerStats.castles     * gameValues.castleDefence
                        }
                        return app.defencePower
                    },
                    calculateGoldPerTurn() {
                        app.goldPerTurn = app.playerStats.hovels        * gameValues.hovelGoldPerTurn
                                        + app.playerStats.miningCamps   * gameValues.miningCampGoldPerTurn
                                        + app.playerStats.wizards       * gameValues.wizardGoldPerTurn
                                        + app.playerStats.banks         * Math.floor(app.playerStats.gold / gameValues.bankedGoldPerUnitGoldPerTurn)
                        return app.goldPerTurn
                    },
                    calculateSoldiersPerTurn() {
                        app.soldiersPerTurn = app.playerStats.barracks * gameValues.barracksSoldiersPerTurn
                                            + app.playerStats.castles  * gameValues.castleSoldiersPerTurn
                        return app.soldiersPerTurn
                    },
                    calculateNetWorth() {
                        app.netWorth = 0
                        if (app.isInGame) {
                            app.netWorth += app.playerStats.gold
                                          + app.playerStats.soldiers    * gameValues.soldierCost
                                          + app.playerStats.spies       * gameValues.spyCost
                                          + app.playerStats.wizards     * gameValues.wizardCost
                                          + app.playerStats.dragons     * gameValues.dragonCost
                                          + app.playerStats.hovels      * gameValues.hovelCost
                                          + app.playerStats.miningCamps * gameValues.miningCampCost
                                          + app.playerStats.banks       * gameValues.bankCost
                                          + app.playerStats.barracks    * gameValues.barracksCost
                                          + app.playerStats.castles     * gameValues.castleCost
                        }
                        return app.netWorth
                    },
                    copyToClipboard(text, focusElementId = "playerStatsTableHeader") {
                        var aux = document.createElement("div")
                        aux.setAttribute("contentEditable", true)
                        aux.innerHTML = text
                        aux.setAttribute("onfocus", "document.execCommand('selectAll',false,null)");
                        document.getElementById(focusElementId).appendChild(aux)
                        aux.focus()
                        document.execCommand("copy")
                        document.getElementById(focusElementId).removeChild(aux)
                    },
                    copyStats() {
                        var touchDevice = (navigator.maxTouchPoints || 'ontouchstart' in document.documentElement)
                        if (!touchDevice) { // Want to allow tooltips on touch devices.
                            app.copyToClipboard(document.getElementById("playerStatsTable").innerHTML)
                        }
                    },
                    addressSelected(address) {
                        console.log("Selected address", address)
                        app.copyToClipboard(address, "account.address")
                    },
                    balanceSelected(balance) {
                        console.log("Selected address balance", balance)
                        app.copyToClipboard(balance, "account.balance")
                    },
                    cancelAllSelection() {
                        console.log("Cancelling selection.")
                        app.kingdomListType = ""
                        app.kingdomSelectionType = "none"
                        app.bodyBackground.backgroundColor = skyColor
                        app.bodyBackground.backgroundImage = skyImage
                        app.clearTooltip()
                    },
                    clearTooltip() {
                        delete app.tooltip.display
                    },
                    transactionError(error) {
                        log("Transaction Error", error)
                        app.bodyBackground.backgroundColor = skyColor
                        app.bodyBackground.backgroundImage = skyImage
                    },
                    joinGame() {
                        if (app.newPlayerName !== undefined && app.newPlayerName.length > 0)
                        {
                            log("Requesting to join game as " + app.newPlayerName + " from address " + app.foundAccounts[0].address + "...")
                            cryptoKingdoms.joinGame(app.newPlayerName,
                                                    { from: app.foundAccounts[0].address, gas: 500000,
                                                     value: web3.toWei(app.gameValues.gameJoinCostEther, "ether") },
                                                    function(error, transactionHash) {
                                                        if (error) {
                                                            app.transactionError(error)
                                                        }
                                                        else {
                                                            log("Starting joinGame transaction " + transactionHash.toString())
                                                            app.setWaitingMessage("Join Game")
                                                            app.notInGameStyle.opacity = 0.0
                                                            app.transactionReceiptPoll(transactionHash, function() {
                                                                app.updateGameStats()
                                                                app.updatePlayerStats()
                                                                app.updateListOfPlayers()
                                                                app.waitingForActionTransactionMessage = ""
                                                            })
                                                        }
                                                    })
                        }
                    },
                    recruitSoldiers() {
                        max = app.formatThousands(Math.floor(app.playerStats.gold / app.gameValues.soldierCost))
                        numberSoldiers = Number(window.prompt("How many soldiers would you like to recruit? (Max " + max + ")"))
                        if (numberSoldiers >= 1)
                        {
                            if (app.playerStats.actions == 0)
                            {
                                alert(noActionsText)
                            }
                            else if (app.playerStats.gold < (numberSoldiers * app.gameValues.soldierCost))
                            {
                                var requiredGold = numberSoldiers * app.gameValues.soldierCost - app.playerStats.gold
                                alert("You need " + app.formatThousands(requiredGold) + " more gold for " + numberSoldiers + " soldiers!")
                            }
                            else
                            {
                                cryptoKingdoms.recruitSoldiers(numberSoldiers,
                                                               { from: app.foundAccounts[0].address, gas: 50000 },
                                                               function(error, transactionHash) {
                                                                    if (error) {
                                                                        app.transactionError(error)
                                                                    }
                                                                    else
                                                                    {
                                                                        log("Starting recruitSoldiers transaction " + transactionHash.toString())
                                                                        app.setWaitingMessage("Recruit Soldiers")
                                                                        app.transactionReceiptPoll(transactionHash, function() {
                                                                            app.updatePlayerStats()
                                                                            app.animateArmyUnits(direction = "left", numberSoldiers, 0, 0, 0)
                                                                        })
                                                                    }
                                                                })
                            }
                        }
                    },
                    recruitSpies() {
                        max = app.formatThousands(Math.floor(app.playerStats.gold / app.gameValues.spyCost))
                        numberSpies = Number(window.prompt("How many spies would you like to recruit? (Max " + max + ")"))
                        if (numberSpies >= 1)
                        {
                            if ((app.playerStats.hovels * gameValues.hovelCapacity) < (app.playerStats.spies + app.playerStats.wizards + numberSpies))
                            {
                                numberHovelsRequired = (app.playerStats.spies + app.playerStats.wizards + numberSpies) - (app.playerStats.hovels * gameValues.hovelCapacity)
                                alert("You don't have enough hovels to hovel " + numberSpies + " more " + (numberSpies == 1 ? "spy" : "spies") + "! (Need " + app.formatThousands(numberHovelsRequired) + " more.)")
                            }
                            else if (app.playerStats.gold < numberSpies * app.gameValues.spyCost)
                            {
                                alert("You don't have enough gold for " + numberSpies + " more " + (numberSpies == 1 ? "spy" : "spies") + "!")
                            }
                            else
                            {
                                cryptoKingdoms.recruitSpies(numberSpies,
                                                            { from: app.foundAccounts[0].address, gas: 58100 },
                                                            function(error, transactionHash) {
                                                                 if (error) {
                                                                     app.transactionError(error)
                                                                 }
                                                                 else
                                                                 {
                                                                     log("Starting recruitSpies transaction " + transactionHash.toString())
                                                                     app.setWaitingMessage("Recruit Spies")
                                                                     app.transactionReceiptPoll(transactionHash, function() {
                                                                         app.updatePlayerStats()
                                                                         app.animateArmyUnits(direction = "left", 0, numberSpies, 0, 0)
                                                                     })
                                                                 }
                                                            })
                            }
                        }
                    },
                    summonWizards() {
                        max = app.formatThousands(Math.floor(app.playerStats.gold / app.gameValues.wizardCost))
                        numberWizards = Number(window.prompt("How many wizards would you like to summon to your realm? (Max " + max + ")"))
                        if (numberWizards >= 1)
                        {
                            if (app.playerStats.actions == 0)
                            {
                                alert(noActionsText)
                            }
                            else if ((app.playerStats.hovels * gameValues.hovelCapacity) < (app.playerStats.spies + app.playerStats.wizards + numberWizards))
                            {
                                numberHovelsRequired = (app.playerStats.spies + app.playerStats.wizards + numberWizards) - (app.playerStats.hovels * gameValues.hovelCapacity)
                                alert("You don't have enough hovels to hovel " + numberWizards + " more " + (numberWizards == 1 ? "wizard" : "wizards") + "! (Need " + app.formatThousands(numberHovelsRequired) + " more.)")
                            }
                            else if (app.playerStats.gold < numberWizards * app.gameValues.wizardCost)
                            {
                                alert("You don't have enough gold for " + numberWizards + " more " + (numberWizards == 1 ? "wizard" : "wizards") + "!")
                            }
                            else
                            {
                                cryptoKingdoms.summonWizards(numberWizards,
                                                             { from: app.foundAccounts[0].address, gas: 67000 },
                                                             function(error, transactionHash) {
                                                                 if (error) {
                                                                     app.transactionError(error)
                                                                 }
                                                                 else
                                                                 {
                                                                     log("Starting summonWizards transaction " + transactionHash.toString())
                                                                     app.setWaitingMessage("Summon Wizards")
                                                                     app.transactionReceiptPoll(transactionHash, function() {
                                                                         app.updatePlayerStats()
                                                                         app.animateArmyUnits(direction = "left", 0, 0, numberWizards, 0)
                                                                     })
                                                                 }
                                                             })
                            }
                        }
                    },
                    trainDragons() {
                        max = app.formatThousands(Math.floor(app.playerStats.gold / app.gameValues.dragonCost))
                        numberDragons = Number(window.prompt("How many dragons would you like to train for destruction? (Max " + max + ")"))
                        if (numberDragons >= 1)
                        {
                            if (app.playerStats.actions == 0)
                            {
                                alert(noActionsText)
                            }
                            else if (app.playerStats.gold < numberDragons * app.gameValues.dragonCost)
                            {
                                alert("You don't have enough gold for " + numberDragons + " more dragon" + (numberDragons == 1 ? " " : "s") + "!")
                            }
                            else
                            {
                                cryptoKingdoms.trainDragons(numberDragons,
                                                            { from: app.foundAccounts[0].address, gas: 63500 },
                                                            function(error, transactionHash) {
                                                                if (error) {
                                                                    app.transactionError(error)
                                                                }
                                                                else {
                                                                    log("Starting trainDragons transaction " + transactionHash.toString())
                                                                    app.setWaitingMessage("Train Dragons")
                                                                    app.transactionReceiptPoll(transactionHash, function() {
                                                                        app.updatePlayerStats()
                                                                        app.animateArmyUnits(direction = "left", 0, 0, 0, numberDragons)
                                                                    })
                                                                }
                                                            })
                            }
                        }
                    },
                    buildHovels() {
                        max = app.formatThousands(Math.floor(app.playerStats.gold / app.gameValues.hovelCost))
                        numberHovels = Number(window.prompt("How many hovels would you like to build? (Max " + max + ")"))
                        if (numberHovels >= 1)
                        {
                            if (app.playerStats.gold < numberHovels * app.gameValues.hovelCost)
                            {
                                var requiredGold = numberHovels * app.gameValues.hovelCost - app.playerStats.gold
                                alert("You need " + app.formatThousands(requiredGold) + " more gold for " + numberHovels + " more hovel" + (numberHovels == 1 ? " " : "s") + "!")
                            }
                            else
                            {
                                cryptoKingdoms.buildHovels(numberHovels,
                                                           { from: app.foundAccounts[0].address, gas: 50000 },
                                                           function(error, transactionHash) {
                                                                if (error) {
                                                                    app.transactionError(error)
                                                                }
                                                                else {
                                                                    log("Starting buildHovel transaction " + transactionHash.toString())
                                                                    app.setWaitingMessage("Build Hovel")
                                                                    app.transactionReceiptPoll(transactionHash, function() {
                                                                        app.updatePlayerStats()
                                                                    })
                                                                }
                                                            })
                            }
                        }
                    },
                    buildMiningCamps() {
                        max = app.formatThousands(Math.floor(app.playerStats.gold / app.gameValues.miningCampCost))
                        numberMiningCamps = Number(window.prompt("How many mining camps would you like to build? (Max " + max + ")"))
                        if (numberMiningCamps >= 1)
                        {
                            if (app.playerStats.actions == 0)
                            {
                                alert(noActionsText)
                            }
                            else if (app.playerStats.gold < numberMiningCamps * app.gameValues.miningCampCost)
                            {
                                var requiredGold = numberMiningCamps * app.gameValues.miningCampCost - app.playerStats.gold
                                alert("You need " + app.formatThousands(requiredGold) + " more gold for " + numberMiningCamps + " mining camps!")
                            }
                            else
                            {
                                cryptoKingdoms.buildMiningCamps(numberMiningCamps,
                                                                { from: app.foundAccounts[0].address, gas: 50000 },
                                                                function(error, transactionHash) {
                                                                    if (error) {
                                                                        app.transactionError(error)
                                                                    }
                                                                    else
                                                                    {
                                                                        log("Starting buildMiningCamps transaction " + transactionHash.toString())
                                                                        app.setWaitingMessage("Build Mining Camp")
                                                                        app.transactionReceiptPoll(transactionHash, function() {
                                                                           app.updatePlayerStats()
                                                                        })
                                                                    }
                                                                })
                            }
                        }
                    },
                    buildBanks() {
                        maxBanksUnderLimit = Math.floor(app.playerStats.gold / app.gameValues.bankCost)
                        if (app.playerStats.banks + maxBanksUnderLimit > gameValues.bankLimit) {
                            maxBanksUnderLimit = gameValues.bankLimit - app.playerStats.banks
                        }
                        max = app.formatThousands(maxBanksUnderLimit)
                        numberBanks = Number(window.prompt("How many banks would you like to build? (Max " + max + ")"))
                        if (numberBanks >= 1)
                        {
                            if (app.playerStats.actions == 0)
                            {
                                alert(noActionsText)
                            }
                            else if (app.playerStats.gold < numberBanks * app.gameValues.bankCost)
                            {
                                var requiredGold = numberBanks * app.gameValues.bankCost - app.playerStats.gold
                                alert("You need " + app.formatThousands(requiredGold) + " more gold for " + numberBanks + " banks!")
                            }
                            else if (app.playerStats.banks + numberBanks > gameValues.bankLimit)
                            {
                                alert("Can't build " + app.formatThousands(numberBanks) + " more banks. Over kingdom bank limit.")
                            }
                            else
                            {
                                cryptoKingdoms.buildBanks(numberBanks,
                                                          { from: app.foundAccounts[0].address, gas: 60000 },
                                                          function(error, transactionHash) {
                                                              if (error) {
                                                                  app.transactionError(error)
                                                              }
                                                              else
                                                              {
                                                                  log("Starting buildBanks transaction " + transactionHash.toString())
                                                                  app.setWaitingMessage("Build Banks")
                                                                  app.transactionReceiptPoll(transactionHash, function() {
                                                                      app.updatePlayerStats()
                                                                  })
                                                              }
                                                          })
                            }
                        }
                    },
                    buildBarracks() {
                        max = app.formatThousands(Math.floor(app.playerStats.gold / app.gameValues.barracksCost))
                        numberBarracks = Number(window.prompt("How many barracks would you like to build? (Max " + max + ")"))
                        if (numberBarracks >= 1)
                        {
                            if (app.playerStats.actions == 0)
                            {
                                alert(noActionsText)
                            }
                            else if (app.playerStats.gold < numberBarracks * app.gameValues.barracksCost)
                            {
                                var requiredGold = numberBarracks * app.gameValues.barracksCost - app.playerStats.gold
                                alert("You need " + app.formatThousands(requiredGold) + " more gold for " + numberBarracks + " barracks!")
                            }
                            else
                            {
                                cryptoKingdoms.buildBarracks(numberBarracks,
                                                             { from: app.foundAccounts[0].address, gas: 50000 },
                                                             function(error, transactionHash) {
                                                                 if (error) {
                                                                     app.transactionError(error)
                                                                 }
                                                                 else
                                                                 {
                                                                     log("Starting buildBarracks transaction " + transactionHash.toString())
                                                                     app.setWaitingMessage("Build Barracks")
                                                                     app.transactionReceiptPoll(transactionHash, function() {
                                                                           app.updatePlayerStats()
                                                                     })
                                                                 }
                                                             })
                            }
                        }
                    },
                    buildCastles() {
                        max = app.formatThousands(Math.floor(app.playerStats.gold / app.gameValues.castleCost))
                        numberCastles = Number(window.prompt("How many castles would you like to build? (Max " + max + ")"))
                        if (numberCastles >= 1)
                        {
                            if (app.playerStats.actions == 0)
                            {
                                alert(noActionsText)
                            }
                            else if (app.playerStats.gold < numberCastles * app.gameValues.barracksCost)
                            {
                                var requiredGold = numberCastles * app.gameValues.barracksCost - app.playerStats.gold
                                alert("You need " + app.formatThousands(requiredGold) + " more gold for " + numberCastles + " castles!")
                            }
                            else
                            {
                                cryptoKingdoms.buildCastles(numberCastles,
                                                            { from: app.foundAccounts[0].address, gas: 50000 },
                                                            function(error, transactionHash) {
                                                                if (error) {
                                                                    app.transactionError(error)
                                                                }
                                                                else
                                                                {
                                                                    log("Starting buildBarracks transaction " + transactionHash.toString())
                                                                    app.setWaitingMessage("Build Castles")
                                                                    app.transactionReceiptPoll(transactionHash, function() {
                                                                            app.updatePlayerStats()
                                                                    })
                                                                }
                                                            })
                            }
                        }
                    },
                    attack() {
                        app.numberAttackingSoldiers = Number(window.prompt("How many soldiers would you like to send to attack?", app.playerStats.soldiers))
                        if (app.numberAttackingSoldiers > 0)
                        {
                            if (app.numberAttackingSoldiers > app.playerStats.soldiers)
                            {
                                alert("You don't have " + app.numberAttackingSoldiers + " soldiers to send to attack!")
                            }
                            else if (app.playerStats.actions == 0)
                            {
                                alert(noActionsText)
                            }
                            else
                            {
                                alert("Select a kingdom to attack!")
                                app.kingdomSelectionType = "attack"
                                app.kingdomListType = " to Attack"
                                app.bodyBackground.backgroundColor = "firebrick"
                                app.clearTooltip()
                            }
                        }
                    },
                    espionage() {
                        if (app.playerStats.spies == 0)
                        {
                            alert("You must recruit at least one spy before you can espionage.")
                        }
                        else if (app.playerStats.gold < gameValues.espionageCost)
                        {
                            alert("You need " + gameValues.espionageCost + " gold to espionage!")
                        }
                        else if (app.playerStats.actions == 0)
                        {
                            alert(noActionsText)
                        }
                        else
                        {
                            alert("Select a kingdom to espionage!")
                            app.kingdomSelectionType = "espionage"
                            app.kingdomListType = " to Espionage"
                            app.bodyBackground.backgroundColor = "black"
                            app.clearTooltip()
                        }
                    },
                    sabotage() {
                        if (app.playerStats.dragons == 0)
                        {
                            alert("You must train at least one dragon before you can sabotage.")
                        }
                        else if (app.playerStats.actions == 0)
                        {
                            alert(noActionsText)
                        }
                        else
                        {
                            alert("Select a kingdom to sabotage!")
                            app.kingdomSelectionType = "sabotage"
                            app.kingdomListType = " to Sabotage"
                            app.bodyBackground.backgroundColor = "#ff3221"
                            app.clearTooltip()
                        }
                    },
                    kingdomSelected(selectedKingdomIndex) {
                        selectedKingdomIndex -= 1
                        if (app.kingdomSelectionType == "none")
                        {
                        }
                        else if (app.kingdomSelectionType == "attack")
                        {
                            if (app.players[selectedKingdomIndex] == app.checkingBlockchainString)
                            {
                                alert("Please wait for the blockchain to finish syncing before attacking a kingdom.")
                            }
                            else
                            {
                                document.getElementById("listOfKingdomsHeader").scrollIntoView({block: "start", behavior: "smooth"})
                                var numberOfSoldiers = app.numberAttackingSoldiers
                                var numberOfSpies = app.playerStats.spies
                                var numberOfWizards = app.playerStats.wizards
                                var numberOfDragons = app.playerStats.dragons
                                cryptoKingdoms.attack(selectedKingdomIndex, numberOfSoldiers,
                                                      { from: app.foundAccounts[0].address, gas: 100000 },
                                                      function(error, transactionHash) {
                                                          if (error) {
                                                              app.transactionError(error)
                                                          }
                                                          else {
                                                              log("Starting attack transaction " + transactionHash.toString())
                                                              app.setWaitingMessage("Attack")
                                                              app.transactionReceiptPoll(transactionHash, function() {
                                                                  app.updatePlayerStats()
                                                                  app.animateArmyUnits(direction = "left",
                                                                    numberOfSoldiers - app.latestCasualties[0],
                                                                    numberOfSpies - app.latestCasualties[1],
                                                                    numberOfWizards - app.latestCasualties[2],
                                                                    numberOfDragons - app.latestCasualties[3])
                                                              })
                                                              app.animateArmyUnits(direction = "right", numberOfSoldiers, numberOfSpies, numberOfWizards, numberOfDragons)
                                                          }
                                                      })
                            }
                        }
                        else if (app.kingdomSelectionType == "espionage")
                        {
                            log("Selected kingdom at index " + selectedKingdomIndex + " to espionage.")
                            if (app.players[selectedKingdomIndex] == app.checkingBlockchainString)
                            {
                                alert("Please wait for the blockchain to finish syncing before spying on another kingdom.")
                            }
                            else
                            {
                                document.getElementById("listOfKingdomsHeader").scrollIntoView({block: "start", behavior: "smooth"})
                                cryptoKingdoms.espionage(selectedKingdomIndex,
                                                         { from: app.foundAccounts[0].address, gas: 150000 },
                                                         function(error, transactionHash) {
                                                             if (error) {
                                                                 app.transactionError(error)
                                                             }
                                                             else {
                                                                 log("Starting espionage transaction " + transactionHash.toString())
                                                                 app.setWaitingMessage("Espionage")
                                                                 app.transactionReceiptPoll(transactionHash, function() {
                                                                     app.updatePlayerStats()
                                                                     app.animateArmyUnits(direction = "left", 0, app.playerStats.spies, 0, 0)
                                                                 })
                                                                 app.animateArmyUnits(direction = "right", 0, app.playerStats.spies, 0, 0)
                                                             }
                                                         })
                            }
                        }
                        else if (app.kingdomSelectionType == "sabotage")
                        {
                            log("Selected kingdom at index " + selectedKingdomIndex + " to sabotage.")
                            if (app.players[selectedKingdomIndex] == app.checkingBlockchainString)
                            {
                                alert("Please wait for the blockchain to finish syncing before sabotaging another kingdom.")
                            }
                            else
                            {
                                document.getElementById("listOfKingdomsHeader").scrollIntoView({block: "start", behavior: "smooth"})
                                var numberOfDragons = app.playerStats.dragons
                                cryptoKingdoms.sabotage(selectedKingdomIndex,
                                                        { from: app.foundAccounts[0].address, gas: 160321 },
                                                        function(error, transactionHash) {
                                                            if (error) {
                                                                app.transactionError(error)
                                                            }
                                                            else {
                                                                log("Starting sabotage transaction " + transactionHash.toString())
                                                                app.setWaitingMessage("Sabotage")
                                                                app.transactionReceiptPoll(transactionHash, function() {
                                                                    app.updatePlayerStats()
                                                                    app.animateArmyUnits(direction = "left", 0, 0, 0, numberOfDragons - app.latestCasualties[3])
                                                                })
                                                                app.animateArmyUnits(direction = "right", 0, 0, 0, numberOfDragons)
                                                            }
                                                        })
                            }
                        }
                        app.kingdomListType = ""
                        app.kingdomSelectionType = "none"
                    },
                    turn() {
                        cryptoKingdoms.turn({ from: app.foundAccounts[0].address, gas: 50000 * app.players.length },
                                            function(error, transactionHash) {
                                                if (error) {
                                                    app.transactionError(error)
                                                }
                                                else {
                                                    log("Starting turn transaction " + transactionHash.toString())
                                                    app.setWaitingMessage("Turn")
                                                    app.transactionReceiptPoll(transactionHash, function() {
                                                        app.updatePlayerStats()
                                                    })
                                                }
                                            })
                    },
                    endGame() {
                        cryptoKingdoms.endGame({ from: app.foundAccounts[0].address, gas: defaultGas },
                                               function(error, transactionHash) {
                                                   if (error) {
                                                       app.transactionError(error)
                                                   }
                                                   else {
                                                       log("Starting endGame transaction " + transactionHash.toString())
                                                       app.setWaitingMessage("End Game")
                                                       app.transactionReceiptPoll(transactionHash, function() {
                                                           app.updateWinnerStats()
                                                       })
                                                   }
                                               })
                    },
                    message(hostMessage) {
                        messageText = window.prompt("Enter a message to broadcast to the public event log.\nCosts " + app.gameValues.messageCostEther + " Ether + transaction fee.", "")
                        if (messageText != "" && messageText !== undefined) {
                            messageText = messageText.charAt(0).toUpperCase() + messageText.slice(1)
                            cryptoKingdoms.message(messageText,
                                                   { from: app.foundAccounts[0].address,
                                                      gas: defaultGas },
                                                   function(error, transactionHash) {
                                                       if (error) {
                                                           app.transactionError(error)
                                                       }
                                                       else {
                                                           log("Starting message transaction " + transactionHash.toString())
                                                           app.setWaitingMessage("Message")
                                                           app.transactionReceiptPoll(transactionHash, function() {})
                                                       }
                                                   })
                        }
                    },
                    async animateArmyUnits(direction = "right", numberOfSoldiers = 0, numberOfSpies = 0, numberOfWizards = 0, numberOfDragons = 0) {
                            if (!window.location.href.includes("alpha")) {
                                return
                            }

                            var armyUnitsNode = document.getElementById("armyUnits")
                            while (armyUnitsNode.hasChildNodes()) {  
                                armyUnitsNode.removeChild(armyUnitsNode.firstChild)
                            }

                            numberOfSoldiers = Math.max(0, numberOfSoldiers)
                            numberOfSpies = Math.max(0, numberOfSpies)
                            numberOfWizards = Math.max(0, numberOfWizards)
                            numberOfDragons = Math.max(0, numberOfDragons)

                            var maxArmyUnitsCanAnimate = 10000
                            var numberOfArmyUnits = numberOfSoldiers + numberOfSpies + numberOfWizards + numberOfDragons
                            if (numberOfArmyUnits > maxArmyUnitsCanAnimate) {
                                numberOfSoldiers *= maxArmyUnitsCanAnimate / numberOfArmyUnits
                                numberOfSpies *= maxArmyUnitsCanAnimate / numberOfArmyUnits
                                numberOfWizards *= maxArmyUnitsCanAnimate / numberOfArmyUnits
                                numberOfDragons *= maxArmyUnitsCanAnimate / numberOfArmyUnits
                                numberOfArmyUnits *= maxArmyUnitsCanAnimate / numberOfArmyUnits
                            }

                            var numberOfSoldiersReleased = 0
                            var numberOfSpiesReleased = 0
                            var numberOfWizardsReleased = 0
                            var numberOfDragonsReleased = 0

                            var optimisedNumberOfUnits = 0

                            for (i = 1; i <= numberOfArmyUnits; i++)
                            {
                                var armyUnitNode = document.createElement("p")
                                armyUnitNode.id = "armyUnit" + i

                                if (direction === "right") {
                                    armyUnitNode.className = "armyUnit armyUnitMoveInLeft" + i
                                }
                                else if (direction === "left") {
                                    armyUnitNode.className = "armyUnit armyUnitMoveInRight" + i
                                }

                                var armyUnitText = "💂"
                                var foundRandomUnitType = false
                                var randomUnitType = Math.floor((Math.random() * 4) % 4)
                                while (!foundRandomUnitType) {
                                    switch (randomUnitType) {
                                        case 0:
                                            if (numberOfSoldiersReleased < numberOfSoldiers)
                                            {
                                                armyUnitText = Math.random() > 0.5 ? "💂" : (Math.random() > 0.5 ? "💂‍♀️" : "💂‍♂️")
                                                numberOfSoldiersReleased += 1
                                                foundRandomUnitType = true
                                                break;
                                            }
                                        case 1:
                                            if (numberOfSpiesReleased < numberOfSpies)
                                            {
                                                armyUnitText = Math.random() > 0.5 ? "🕵️" : (Math.random() > 0.5 ? "🕵️‍♀️" : "🕵️‍♂️")
                                                numberOfSpiesReleased += 1
                                                foundRandomUnitType = true
                                                break;
                                            }
                                        case 2:
                                            if (numberOfWizardsReleased < numberOfWizards)
                                            {
                                                armyUnitText = Math.random() > 0.5 ? "🧙‍♂️" : (Math.random() > 0.5 ? "🧙‍♀️" : "🧙‍♂️")
                                                numberOfWizardsReleased += 1
                                                foundRandomUnitType = true
                                                break;
                                            }
                                        case 3:
                                            if (numberOfDragonsReleased < numberOfDragons)
                                            {
                                                armyUnitText = "🐲"
                                                numberOfDragonsReleased += 1
                                                foundRandomUnitType = true
                                                break;
                                            }
                                        default:
                                            randomUnitType = 0
                                            break;
                                    }
                                }

                                var groupSize = 0
                                if (Math.random() > 0.25)
                                {
                                    if (randomUnitType == 0)
                                    {
                                        groupSize = Math.random() > 0.5 ? 5 : 10
                                        if ((numberOfSoldiers - numberOfSoldiersReleased) > groupSize)
                                        {
                                            armyUnitText += "  "
                                            armyUnitText = armyUnitText.repeat(groupSize)
                                            numberOfSoldiersReleased += groupSize - 1
                                            optimisedNumberOfUnits += groupSize - 1
                                            numberOfArmyUnits -= groupSize - 1
                                        }
                                    }
                                    if (randomUnitType == 2)
                                    {
                                        groupSize = 2
                                        if ((numberOfWizards - numberOfWizardsReleased) > groupSize)
                                        {
                                            armyUnitText += "  "
                                            armyUnitText = armyUnitText.repeat(groupSize)
                                            numberOfWizardsReleased += groupSize - 1
                                            optimisedNumberOfUnits += groupSize - 1
                                            numberOfArmyUnits -= groupSize - 1
                                        }
                                    }
                                }

                                var armyUnitTextNode = document.createTextNode(armyUnitText)
                                armyUnitNode.appendChild(armyUnitTextNode)

                                armyUnitsNode.appendChild(armyUnitNode)

                                var moveInSpeedSeconds = 6

                                var armyUnitMovementStyleId = "armyUnitMovementStyle" + i
                                if (document.getElementById(armyUnitMovementStyleId) === null) {
                                    var armyUnitMovementStyle = document.createElement("style")
                                    armyUnitMovementStyle.type = "text/css"
                                    armyUnitMovementStyle.id = armyUnitMovementStyleId
                                    var offscreenMarginLeft = (-50 - (i * 0.75)) + "%"
                                    var offscreenMarginRight = (150 + (i * 0.75)) + "%"
                                    var moveInMarginLeft = (-10 - (i * 1.5) - (groupSize * 10)) + "%"
                                    var moveInMarginRight = (110 + (i * 1.5) + (groupSize * 10)) + "%"
                                    var moveOutRightSpeed = (9 + (0.1 * Math.random())) + "s"
                                    var moveOutLeftSpeed = (9 + (0.1 * Math.random())) + "s"
                                    armyUnitMovementStyle.innerHTML = "@keyframes armyUnitMoveInLeft" + i + "Keyframes { 0% { margin-left: " + offscreenMarginLeft + "; } 100% { margin-left: " + moveInMarginLeft + "; } }"
                                    armyUnitMovementStyle.innerHTML += "@keyframes armyUnitMoveInRight" + i + "Keyframes { 0% { margin-left: " + offscreenMarginRight + "; } 100% { margin-left: " + moveInMarginRight + "; } }"
                                    armyUnitMovementStyle.innerHTML += "@keyframes armyUnitMoveOutLeft" + i + "Keyframes { 0% { margin-left: " + moveInMarginLeft + "; } 100% { margin-left: " + offscreenMarginRight + "; } }"
                                    armyUnitMovementStyle.innerHTML += "@keyframes armyUnitMoveOutRight" + i + "Keyframes { 0% { margin-left: " + moveInMarginRight + "; } 100% { margin-left: " + offscreenMarginLeft + "; } }"
                                    armyUnitMovementStyle.innerHTML += " .armyUnitMoveInLeft" + i + " { animation: armyUnitMoveInLeft" + i + "Keyframes " + moveInSpeedSeconds + "s; -moz-animation: armyUnitMoveInLeft" + i + "Keyframes " + moveInSpeedSeconds + "s; -webkit-animation: armyUnitMoveInLeft" + i + "Keyframes " + moveInSpeedSeconds + "s; -o-animation: armyUnitMoveInLeft" + i + "Keyframes " + moveInSpeedSeconds + "s; animation-timing-function: ease-out; animation-fill-mode: forwards; }"
                                    armyUnitMovementStyle.innerHTML += " .armyUnitMoveInRight" + i + " { animation: armyUnitMoveInRight" + i + "Keyframes " + moveInSpeedSeconds + "s; -moz-animation: armyUnitMoveInRight" + i + "Keyframes " + moveInSpeedSeconds + "s; -webkit-animation: armyUnitMoveInRight" + i + "Keyframes " + moveInSpeedSeconds + "s; -o-animation: armyUnitMoveInRight" + i + "Keyframes " + moveInSpeedSeconds + "s; animation-timing-function: ease-out; animation-fill-mode: forwards; }"
                                    armyUnitMovementStyle.innerHTML += " .armyUnitMoveOutRight" + i + " { animation: armyUnitMoveOutRight" + i + "Keyframes " + moveOutRightSpeed + "; -moz-animation: armyUnitMoveOutRight" + i + "Keyframes " + moveOutRightSpeed + "; -webkit-animation: armyUnitMoveOutRight" + i + "Keyframes " + moveOutRightSpeed + "; -o-animation: armyUnitMoveOutRight" + i + "Keyframes " + moveOutRightSpeed + "; animation-timing-function: ease-in; animation-fill-mode: forwards; }"
                                    armyUnitMovementStyle.innerHTML += " .armyUnitMoveOutLeft" + i + " { animation: armyUnitMoveOutLeft" + i + "Keyframes " + moveOutLeftSpeed + "; -moz-animation: armyUnitMoveOutLeft" + i + "Keyframes " + moveOutLeftSpeed + "; -webkit-animation: armyUnitMoveOutLeft" + i + "Keyframes " + moveOutLeftSpeed + "; -o-animation: armyUnitMoveOutLeft" + i + "Keyframes " + moveOutLeftSpeed + "; animation-timing-function: ease-in; animation-fill-mode: forwards; }"
                                    document.getElementsByTagName('head')[0].appendChild(armyUnitMovementStyle)
                                }
                            }

                            app.previousAnimateArmyUnitsArgs = { "direction" : "right", "numberOfSoldiers" : numberOfSoldiers, "numberOfSpies" : numberOfSpies, "numberOfWizards" : numberOfWizards, "numberOfDragons" : numberOfDragons }

                            await app.sleep(moveInSpeedSeconds * 1000)

                            for (i = 1; i <= numberOfArmyUnits; i++) {
                                armyUnitNode = document.getElementById("armyUnit" + i)
                                if (direction === "right") {
                                    armyUnitNode.className = "armyUnit armyUnitMoveOutLeft" + i
                                }
                                else if (direction === "left") {
                                    armyUnitNode.className = "armyUnit armyUnitMoveOutRight" + i
                                }
                                await app.sleep(50 + 300 * app.randomValue)
                            }

                            await app.sleep(7 * 1000)
                    },
                    setupEventLog() {
                        var handledEventTransactionHashes = []
                        function handleEvent(error, event) {
                            if (error) {
                                log("Event Error", error)
                                return
                            }
                            handleEventIndex = event.logIndex
                            web3.eth.getBlock(event.blockNumber, function(error, eventBlock) {
                                eventTime = new Date(eventBlock.timestamp * 1000)
                                eventText = ""

                                currentDateTime = new Date()
                                timeSinceEventSeconds = (currentDateTime - eventTime) / 1000

                                if (event.event == "newPlayerJoined")
                                {
                                    if (eventBlock.timestamp > app.gameStats.gameStartTimeSeconds)
                                    {
                                        if (!event.args.playerName.toLowerCase().startsWith("the"))
                                            eventText += "The "
                                        eventText += event.args.playerName
                                        if (!event.args.playerName.toLowerCase().includes("kingdom"))
                                            eventText += " Kingdom"
                                        if (timeSinceEventSeconds < 5 * 60)
                                            eventText += " has"
                                        eventText += " joined the game! 🏰"
                                        app.updateGameStats()
                                    }
                                }
                                else if (event.event == "attackCompleted")
                                {
                                    attackingArmySoldierDeaths = Number(event.args.soldierDeaths.c[0])
                                    attackingArmyWizardDeaths = Number(event.args.wizardDeaths.c[0])
                                    attackingArmyDragonDeaths = Number(event.args.dragonDeaths.c[0])
                                    app.latestCasualties = [attackingArmySoldierDeaths, 0, attackingArmyWizardDeaths, attackingArmyDragonDeaths]
                                    goldExchanged = Number(event.args.goldExchanged.c[0])
                                    let goldImage = "💰"
                                    goldEmoji = goldImage
                                    deathEmoji = "💀"
                                    if (goldExchanged == 0 && attackingArmySoldierDeaths == 0)
                                    {
                                        eventText = "An attack was attempted... But the difference in army size was so large that one army couldn't find the other! "
                                    }
                                    else if (goldExchanged > 0)
                                    {
                                        theftWord = "the theft"
                                        if (goldExchanged < 10)
                                        {
                                            theftWord = "pinch"
                                        }
                                        else if (goldExchanged < 1000)
                                        {
                                            switch (goldExchanged % 7) {
                                                case 1: theftWord = "a fleecing"; break;
                                                case 2: theftWord = "a looting"; break;
                                                case 3: theftWord = "a pillaging"; break;
                                                case 4: theftWord = "a pilfering"; break;
                                                case 5: theftWord = "a looting"; break;
                                                default: theftWord = "a theft"; break;
                                            }
                                        }
                                        else
                                        {
                                            goldExchangedMinusCosts = goldExchanged
                                                                     - (attackingArmySoldierDeaths * gameValues.soldierCost)
                                                                      - (attackingArmyWizardDeaths * gameValues.wizardCost)
                                                                      - (attackingArmyDragonDeaths * gameValues.dragonCost)
                                            if (goldExchangedMinusCosts >= 1000) goldEmoji += goldImage
                                            if (goldExchangedMinusCosts >= 10000) goldEmoji += goldImage
                                            if (goldExchangedMinusCosts >= 100000) goldEmoji += goldImage
                                            if (goldExchangedMinusCosts >= 1000000) goldEmoji += goldImage
                                            if (goldExchangedMinusCosts >= 10000000) goldEmoji += goldImage
                                            if (goldExchangedMinusCosts >= 100000000) goldEmoji += goldImage
                                            if (goldExchangedMinusCosts >= 1000000000) goldEmoji += goldImage
                                            if (goldExchangedMinusCosts >= 10000000000) goldEmoji += goldImage
                                            if (goldExchangedMinusCosts >= 100000000000) goldEmoji += goldImage
                                            switch (goldExchanged % 7) {
                                                case 1: theftWord = "a looting"; break;
                                                case 2: theftWord = "a ransacking"; break;
                                                case 3: theftWord = "a plundering"; break;
                                                case 4: theftWord = "a ravaging"; break;
                                                case 5: theftWord = "a pillaging"; break;
                                                default: theftWord = "a theft"; break;
                                            }
                                        }
                                        eventText = "An attack resulted in " + theftWord + " of " + app.formatEnglishNumber(goldExchanged) + " gold! " + goldEmoji + " "
                                        if (attackingArmySoldierDeaths > 0)
                                        {
                                            eventText += " " + app.formatEnglishNumber(attackingArmySoldierDeaths, true) + " soldier" + (attackingArmySoldierDeaths > 1  ? "s were " : " was ")
                                            if (attackingArmySoldierDeaths < 1000)
                                            {
                                                switch (((attackingArmySoldierDeaths << 4) + attackingArmyWizardDeaths) % 16) {
                                                    case 0: eventText += "lost"; break;
                                                    case 1: eventText += "killed"; break;
                                                    case 2: eventText += "eliminated"; break;
                                                    case 3: eventText += "slaughtered"; break;
                                                    case 4: eventText += "defeated"; break;
                                                    case 5: eventText += "lost"; break;
                                                    case 6: eventText += "lost"; break;
                                                    case 7: eventText += "lost"; break;
                                                    default: eventText += "killed"; break;
                                                }
                                            }
                                            else
                                            {
                                                switch (((attackingArmySoldierDeaths << 4) + attackingArmyWizardDeaths) % 16) {
                                                    case 0: eventText += "lost"; break;
                                                    case 1: eventText += "tragically lost"; break;
                                                    case 2: eventText += "eliminated"; break;
                                                    case 3: eventText += "slaughtered"; break;
                                                    case 4: eventText += "defeated"; break;
                                                    default: eventText += "killed"; break;
                                                }
                                            }
                                            eventText += " in the fight. "
                                        }
                                    }
                                    else
                                    {
                                        defendedWord = "defended"
                                        switch (attackingArmySoldierDeaths % 7) {
                                            case 1: defendedWord = "repelled"; break;
                                            case 2: defendedWord = "fought off"; break;
                                            case 3: defendedWord = "thwarted"; break;
                                            case 4: defendedWord = "thwarted"; break;
                                            default: defendedWord = "defended"; break;
                                        }
                                        eventText = "An attack was " + defendedWord + "! 🛡 "
                                        eventText += app.formatEnglishNumber(attackingArmySoldierDeaths, true) + " "
                                        if (attackingArmySoldierDeaths)
                                            eventText += "flailing"
                                        eventText += " soldiers fell to their deaths! "
                                    }

                                    if (attackingArmyWizardDeaths > 0)
                                    {
                                        eventText += app.formatEnglishNumber(attackingArmyWizardDeaths, shouldCapitalize = true)
                                        eventText += " wizard" + (attackingArmyWizardDeaths > 1  ? "s" : "") + " "
                                        if (attackingArmyWizardDeaths == 1) {
                                            switch ((((goldExchanged + attackingArmySoldierDeaths) << attackingArmySoldierDeaths) >> 4 + attackingArmySoldierDeaths) % 128) {
                                                case 0: eventText += "was knocked off a bridge into a chasm."; break;
                                                case 1: eventText += "became trapped in another realm!"; break;
                                                case 2: eventText += "disappeared into thin air!"; break;
                                                case 3: eventText += "transformed into a frog and hopped into a pond!"; deathEmoji = "🐸"; break;
                                                case 4: eventText += "faced a spell that could not be deflected!"; break;
                                                case 5: eventText += "left to go live in a cave!"; break;
                                                case 6: eventText += "was brutally cut down!"; break;
                                                case 7: eventText += "held off a demon just long enough to let the survivors to escape!"; break;
                                                case 8: eventText += "failed to deflect a killing curse!"; break;
                                                case 9: eventText += "'s spirit moved on to a space outside of thought and time."; break;
                                                case 10: eventText += "could not beat the odds he was up against!"; break;
                                                case 11: eventText += "could not beat the odds she was up against!"; break;
                                                case 12: eventText += "was burned alive by a wild dragon!"; break;
                                                case 13: eventText += "fell into an everlasting sleep."; break;
                                                case 14: eventText += "opened a hovel door and was sucked into a vortex that was tunnelling through time and space."; break;
                                                case 15: eventText += "fell into a cellar. "; break;
                                                case 16: eventText += "fell into the nothingness of The Great Void!"; break;
                                                case 17: eventText += "fell back through time to a dark age before the blockchain!"; break;
                                                case 18: eventText += "was pushed into an abyss!"; break;
                                                case 19: eventText += "went into hiding!"; break;
                                                case 20: eventText += "left precisely when he meant to!"; break;
                                                case 21: eventText += "left, never to return again. But wherever he's going, he will arive precisely when he means to."; break;
                                                case 22: eventText += "went into hiding!"; break;
                                                case 23: eventText += "left the kingdom."; break;
                                                case 24: eventText += "feared the future wrath of her enemies and went into hiding!"; break;
                                                case 25: eventText += "broke her wand. She left the kingdom to embark on a quest to be rewarded with a new one."; break;
                                                case 26: eventText += "was pulled out from the ether of this realm by a greater force."; break;
                                                case 27: eventText += "was taken captive. A rescue mission was attempted... but it failed... He's gone."; break;
                                                case 28: eventText += "was cursed and had to leave the greater cause to seek a remedy."; break;
                                                case 29: eventText += "died in an explosion of magical power."; break;
                                                case 30: eventText += "encountered a fell beast and was driven away."; break;
                                                case 31: eventText += "disappeared leaving nothing behind but a cloak which softly dropped to the ground."; break;
                                                case 32: eventText += "abandonned the cause to seek a darker power."; break;
                                                case 33: eventText += "broke his wand. He left the kingdom to embark on a quest to be rewarded with a new one."; break;
                                                case 34: eventText += "left, never to return again. But wherever she's going, she will arive precisely when she means to."; break;
                                                case 35: eventText += "who was once one with the spirit of this Earth passed on leaving an otherworldly fragment behind."; break;
                                                case 36: eventText += "got distracted chasing a bunny down a rabbit hole."; deathEmoji = "🐰"; break;
                                                case 37: eventText += "felt the presence of a dark spirit overhead and, turning to face the sky, lifted a shield above his head to take a strike from a bolt of lightning hurtling down towards him. But the power of the energy was too great for the wizard to withstand."; break;
                                                case 38: eventText += "was sent back to where he came."; break;
                                                case 39: eventText += "was sent back to where she came."; break;
                                                case 40: eventText += "was forced into exile after failing to defeat the target kingdom's leader."; break;
                                                case 41: eventText += "opened a hovel door and was sucked into a vortex that was tunnelling across space and time."; break;
                                                case 42: eventText += "fended off a soldier squad, took an arrow to the knee, couldn't remember the healing spell, collapsed to the floor, passed on from the mortal realm into the space between realms, and reincarnated as a goat."; if (attackingArmyDragonDeaths == 0) deathEmoji = "🐐"; break;
                                                case 43: eventText += "could not overcome the odds she was up against!"; break;
                                                case 44: eventText += "could not overcome the odds he was up against!"; break;
                                                default: eventText += "was killed."; break;
                                            }
                                        }
                                        else if (attackingArmyWizardDeaths == 2) {
                                            switch ((((goldExchanged + attackingArmySoldierDeaths + attackingArmyWizardDeaths) << 2) + goldExchanged - attackingArmySoldierDeaths) % 64) {
                                                case 1: eventText += "fell in love and eloped to another world. ❤️"; deathEmoji = ""; break;
                                                case 2: eventText += "fell in love and went to a different world. ❤️"; deathEmoji = ""; break;
                                                case 3: eventText += "fell in love and eloped to another land. ❤️"; deathEmoji = ""; break;
                                                case 4: eventText += "fell in love and escaped to another dimension. ❤️"; deathEmoji = ""; break;
                                                case 5: eventText += "fell in love and rode a unicorn up to the heavens. 🦄"; deathEmoji = ""; break;
                                                case 6: eventText += "escaped in a boat and paddled downstream into an unexpected waterfall."; break;
                                                default: eventText += "were killed."; break;
                                            }
                                        }
                                        else if (attackingArmyWizardDeaths <= 3) {
                                            switch ((((goldExchanged + attackingArmySoldierDeaths + attackingArmyWizardDeaths) << 2) + goldExchanged - attackingArmySoldierDeaths) % 32) {
                                                case 1: eventText += "banded together to leave their master."; break;
                                                case 2: eventText += "plotted to overthrow the attacker upon return, but were caught and banished from the land."; break;
                                                case 3: eventText += "decided they didn't like the weather and left."; break;
                                                case 4: eventText += "were summoned to another realm."; break;
                                                case 5: eventText += "could not deflect the spells they were up against!"; break;
                                                case 6: eventText += "disappeared into thin air, leaving only their cloaks behind!"; break;
                                                case 7: eventText += "went into hiding."; break;
                                                case 8: eventText += "abandonned the cause."; break;
                                                case 9: eventText += "left the realm."; break;
                                                case 10: eventText += "never returned."; break;
                                                case 11: eventText += "took to the skies on broomsticks, never to be seen again."; break;
                                                case 12: eventText += "were beckoned to the cosmos and have left the kingdom."; deathEmoji = "🌌"; break;
                                                case 13: eventText += "were turned into stone."; break;
                                                case 14: eventText += "were caught in an explosion of magic."; break;
                                                case 15: eventText += "encountered a fell demon and are engaged in an ongoing battle. Their odds don't look good."; break;
                                                case 16: eventText += "have caught a case of the blues and can't go on no more..."; deathEmoji = "♭"; break;
                                                default: eventText += "were killed."; break;
                                            }                                                        }
                                        else if (attackingArmyWizardDeaths <= 20) {
                                            switch ((attackingArmySoldierDeaths + attackingArmyWizardDeaths) % 32) {
                                                case 1: eventText += "were recalled by their masters to a more noble cause."; break;
                                                case 2: eventText += "ran away!"; break;
                                                case 3: eventText += "went on vacation!"; break;
                                                case 4: eventText += "went back to the dark realm from which they came!"; break;
                                                case 5: eventText += "could not deflect the spells they were up against!"; break;
                                                case 6: eventText += "disappeared into thin air, leaving only their cloaks behind!"; break;
                                                case 7: eventText += "went into hiding."; break;
                                                case 8: eventText += "abandonned the cause."; break;
                                                case 9: eventText += "left the realm."; break;
                                                case 10: eventText += "never returned."; break;
                                                case 11: eventText += "were turned into stone."; break;
                                                case 12: eventText += "disappeared leaving nothing but their cloaks which slowly fluttered down to the ground..."; break;
                                                case 13: eventText += "banded together and left in search of a greater cause..."; break;
                                                case 14: eventText += "dared to fight their opponent's fortress with the might of a spell conjoured from words long remembered but alas their time was at an end."; break;
                                                case 15: eventText += "confidently conjoured a water spirit to assist them in their ways. After the battle had ended the water spirit beckoned them closer and took them to another world."; break;
                                                default: eventText += "were killed."; break;
                                            }
                                        }
                                        else if (attackingArmyWizardDeaths < 300) {
                                            switch (((attackingArmySoldierDeaths << 4) + attackingArmyWizardDeaths) % 32) {
                                                case 1: eventText += "were trapped in another realm..."; break;
                                                case 2: eventText += "disappeared into mist..."; break;
                                                case 3: eventText += "conjoured themselves out!"; break;
                                                case 4: eventText += "fell into an abyss..."; break;
                                                case 5: eventText += "were brutally cut down!"; break;
                                                case 6: eventText += "encountered the Monkey King and entered into an unwise battle."; break;
                                                case 7: eventText += "were chased away by the Bull Demon King!"; break;
                                                case 8: eventText += "were defeated."; break;
                                                case 9: eventText += "tried to cross a rickety old bridge which collapsed."; break;
                                                case 10: eventText += "were misled to their deaths."; break;
                                                default: eventText += "were killed!"; break;
                                            }
                                        }
                                        else {
                                            switch (((attackingArmySoldierDeaths << 4) + attackingArmyWizardDeaths) % 8) {
                                                case 1: eventText += "have been summoned to another world..."; break;
                                                case 2: eventText += "were recalled to The Great Spirit!"; break;
                                                case 3: eventText += "have gone to the other side."; break;
                                                case 4: eventText += "fallen into an abyss!"; break;
                                                case 5: eventText += "were brutally beaten down."; break;
                                                case 6: eventText += "deserted in their droves!"; break;
                                                case 7: eventText += "accidently conjoured a temporal black hole which instantly consumed them."; break;
                                                default: eventText += "abandonned the cause in their droves!"; break;
                                            }
                                        }
                                    }
                                    if (attackingArmyDragonDeaths > 0)
                                    {
                                        eventText += " "
                                        if (attackingArmyDragonDeaths == 1) {
                                            eventText += "One dragon "
                                            switch (((attackingArmySoldierDeaths << 4) + attackingArmyWizardDeaths + attackingArmyDragonDeaths) % 32 ) {
                                                case 1: eventText += "perished on the journey."; break;
                                                case 2: eventText += "tried to escape. But couldn't!"; break;
                                                case 3: eventText += "got itself stuck in a cave and had to be left behind!"; break;
                                                case 4: eventText += "fell into a ravine!"; break;
                                                case 5: eventText += "was crushed by a falling boulder!"; break;
                                                case 6: eventText += "was defeated by a band of daring soldiers!"; break;
                                                case 7: eventText += "was slain by the king."; break;
                                                case 8: eventText += "was slain by the queen."; break;
                                                case 9: eventText += "was slain by a prince."; break;
                                                case 10: eventText += "was slain by a princess."; break;
                                                case 11: eventText += "should have been fed more."; break;
                                                case 12: eventText += "died on the journey back."; break;
                                                case 13: eventText += "had an evil spell cast upon it."; break;
                                                case 14: eventText += "decided fighting was not for it and flew away."; break;
                                                case 15: eventText += "took off into the clear sky, never to be seen again."; break;
                                                case 16: eventText += "was struck my lightning, a clear from of the Gods."; break;
                                                case 17: eventText += "knocked through a supporting wall and was crushed by the weight of a castle."; break;
                                                default: eventText += "was lost along the way."; break;
                                            }
                                        }
                                        else if (attackingArmyDragonDeaths < 10) {
                                            eventText += app.formatEnglishNumber(attackingArmyDragonDeaths, shouldCapitalize = true) + " dragons "
                                            switch (((attackingArmySoldierDeaths << 4) + attackingArmyWizardDeaths + attackingArmyDragonDeaths) % 19 ) {
                                                case 1: eventText += "took off into the clouds!"; deathEmoji = "☁️"; break;
                                                case 2: eventText += "were blown away into the clouds!"; deathEmoji = "☁️"; break;
                                                case 3: eventText += "took to the skies and were replaced with clouds!"; deathEmoji = "☁️ ☁️ ☁️"; break;
                                                case 4: eventText += "soared high into the sky and above the clouds!"; deathEmoji = "☁️☁️☁️"; break;
                                                case 5: eventText += "ascended into the clouds!"; deathEmoji = "☁️"; break;
                                                case 6: eventText += "were never to be seen again, after being hidden by the clouds!"; deathEmoji = "☁️"; break;
                                                case 7: eventText += "were never to be seen again after disappearing into the clouds!"; deathEmoji = "☁️☁️"; break;
                                                case 8: eventText += "were blown away by a gale force wind!"; deathEmoji = ""; break;
                                                default: eventText += "were lost along the way."; break;
                                            }
                                        }
                                        else {
                                            eventText += app.formatEnglishNumber(attackingArmyDragonDeaths, shouldCapitalize = true) + " dragons "
                                            switch (((attackingArmySoldierDeaths << 4) + attackingArmyWizardDeaths + attackingArmyDragonDeaths) % 16 ) {
                                                case 1: eventText += "perished on the journey!"; break;
                                                case 2: eventText += "flocked together and flew off into the clouds!"; deathEmoji = "☁️"; break;
                                                case 3: eventText += "fell out of the sky into a lake!"; break;
                                                case 4: eventText += "fell from the sky into a ravine!"; break;
                                                case 5: eventText += "fell from the sky into an abyss!"; break;
                                                case 6: eventText += "were swept away by an unexpected tornado!"; break;
                                                case 7: eventText += "were slaughtered!"; break;
                                                case 8: eventText += "were chased by a mighty deamon into the dark skies never to be seen again."; break;
                                                case 9: eventText += "were knocked back beyond the event horizon after an encounter with the might of a dark force unbeknown."; break;
                                                case 10: eventText += "were blown away by a freak tornado."; break;
                                                case 11: eventText += "flew too close to the sun and were scorched to death"; break;
                                                case 12: eventText += "were hit by an onslaught of arrows and fell out of the sky to their deaths."; break;
                                                case 13: eventText += "were pulled into a summoned tornado and hurled away."; break;
                                                case 14: eventText += "were unable to penetrate the defences of the target kingdom and were killed."; break;
                                                default: eventText += "were lost along the way!"; break;
                                            }
                                        }
                                    }
                                    if (attackingArmySoldierDeaths > 0 || attackingArmyWizardDeaths > 0 || attackingArmyDragonDeaths > 0) {
                                        eventText += " " + deathEmoji
                                    }
                                    app.updatePlayerStats()
                                }
                                else if (event.event == "spyReported")
                                {
                                    spyDetail = Number(event.args.detail.c[0])
                                    spyKingdomName = event.args.name
                                    spyInfo = Number(event.args.info)
                                    spyMoreInfo = Number(event.args.moreInfo)
                                    spyEmoji = (((spyInfo + spyMoreInfo) % 2) == 0) ? "🕵️‍♂️" : "🕵️‍♀️"
                                    eventText = "A rumour circulated that "
                                    if (spyDetail == 0)
                                    {
                                        eventText += (spyInfo == 1 ? "a spy" : (app.formatEnglishNumber(spyInfo) + " spies have")) + " failed to infiltrate the "
                                        if (!spyKingdomName.toLowerCase().includes("kingdom"))
                                            eventText += "kingdom of "
                                        eventText += spyKingdomName + "..."
                                    }
                                    else if (spyDetail == 1)
                                    {
                                        eventText += spyKingdomName + " holds "
                                        if (spyInfo == 0)
                                            eventText += "absolutely"
                                        else if (spyInfo < 10)
                                            switch (spyInfo % 16) {
                                                case 1: eventText += "a measly"; break;
                                                case 2: eventText += "a scanty"; break;
                                                case 3: eventText += "an ungenerous"; break;
                                                case 4: eventText += "an insufficient for pillaging"; break;
                                                case 5: eventText += "the remains of a spending spree totaling"; break;
                                                case 6: eventText += "a penny-pinching"; break;
                                                case 7: eventText += "a tight-arsed"; break;
                                                case 8: eventText += "a tight-assed"; break;
                                                case 9: eventText += "a money-grubbing"; break;
                                                case 10: eventText += "tight"; break;
                                                default: eventText += "a meager"; break;
                                            }
                                        else if (spyInfo < 500)
                                            switch (spyInfo % 18) {
                                                case 1: eventText += "a measly"; break;
                                                case 2: eventText += "a scanty"; break;
                                                case 3: eventText += "a generous"; break;
                                                case 4: eventText += ""; break;
                                                case 5: eventText += "an inadequate"; break;
                                                case 6: eventText += "a penny-pinching"; break;
                                                case 7: eventText += "a tight-fisted"; break;
                                                case 8: eventText += "penurious"; break;
                                                case 9: eventText += "a treasure chest packed with"; break;
                                                case 10: eventText += "three treasure chests packed with"; break;
                                                case 11: eventText += "a box containing"; break;
                                                default: eventText += ""; break;
                                            }
                                        else if (spyInfo < 10000)
                                            switch (spyInfo % 16) {
                                                case 1: eventText += "vaults containing"; break;
                                                case 2: eventText += "treasure chests containing"; break;
                                                case 3: eventText += "a mountain of golden goods totaling"; break;
                                                case 4: eventText += "treasure chests worth"; break;
                                                default: eventText += "reserves of"; break;
                                            }
                                        else if (spyInfo < 100000)
                                            switch (spyInfo % 9) {
                                                case 1: eventText += "reserves of"; break;
                                                case 2: eventText += "many treasure chests containing"; break;
                                                case 3: eventText += "volts containing vast reserves of"; break;
                                                default: eventText += ""; break;
                                            }
                                        eventText += " " + app.formatEnglishNumber(spyInfo) + " gold"
                                        if (spyMoreInfo == 0)
                                            eventText += "."
                                        else
                                            eventText += " guarded by " + app.formatEnglishNumber(spyMoreInfo) + " dragon" + (spyMoreInfo > 1 ? "s" : "") + "... "
                                    }
                                    else if (spyDetail == 2)
                                    {
                                        eventText += spyKingdomName + " holds an army of " + app.formatEnglishNumber(spyInfo) + " soldier" + (spyInfo > 1 ? "s" : "") + "."
                                        if (spyMoreInfo == 0) {
                                        }
                                        else if (spyMoreInfo == 1)
                                            eventText += " A single bank is tasked with all the accounting. 🏦 "
                                        else if (spyMoreInfo == 2)
                                            eventText += " A duopoly has gripped the banking sector. "
                                        else if (spyMoreInfo > gameValues.bankLimit / 4)
                                            eventText += " Their banking sector is flourishing with " + app.formatEnglishNumber(spyMoreInfo) + " banks. 🏦 "
                                        else if (spyMoreInfo > gameValues.bankLimit / 2)
                                            eventText += " Their banking sector is blossoming with " + app.formatEnglishNumber(spyMoreInfo) + " banks. 🏦🏦 "
                                        else
                                            eventText += " Their banking sector is booming with " + app.formatEnglishNumber(spyMoreInfo) + " banks! 🏦🏦🏦 "
                                    }
                                    else if (spyDetail == 3)
                                    {
                                        eventText += spyKingdomName + " has built "
                                        eventText += app.formatEnglishNumber(spyInfo - app.gameValues.startingNumberMiningCamps)
                                        eventText += " mining camp" + (((spyInfo - app.gameValues.startingNumberMiningCamps) != 1) ? "s" : "")
                                        if (spyMoreInfo == 0)
                                        {
                                            eventText += "."
                                        }
                                        else
                                        {
                                            eventText += " and " + app.formatEnglishNumber(spyMoreInfo) + " castle" + (spyMoreInfo > 1 ? "s" : "") + "... "
                                        }
                                    }
                                    else
                                    {
                                        eventText = "nobody could make sense of... 🐣"
                                    }
                                    eventText += " " + spyEmoji
                                    app.updatePlayerStats()
                                }
                                else if (event.event == "sabotaged")
                                {
                                    defended = false

                                    sabotagedGold = Number(event.args.sabotagedGold.c[0])
                                    sabotagedDragons = Number(event.args.sabotagedDragons.c[0])
                                    sabotagedHovels = Number(event.args.sabotagedHovels.c[0])
                                    sabotagedMiningCamps = Number(event.args.sabotagedMiningCamps.c[0])
                                    sabotagedBanks = Number(event.args.sabotagedBanks.c[0])
                                    dragonsKilled = Number(event.args.dragonsKilled.c[0])

                                    app.latestCasualties = [0, 0, 0, dragonsKilled]

                                    emojis = "🏃‍♂🐉"

                                    if (sabotagedGold <= 1 && sabotagedDragons <= 1 && sabotagedHovels == 0 && sabotagedMiningCamps == 0)
                                    {
                                        eventText = "A sabotage was successfully defended. 🛡 "
                                        defended = true
                                    }
                                    else
                                    {
                                        eventText = "A sabotage resulted in the loss of "
                                    
                                        switch (((sabotagedGold + sabotagedDragons + sabotagedMiningCamps)
                                                    << 4 + sabotagedGold + sabotagedMiningCamps) % 4) {
                                            case 0: emojis = "🏃‍♂🐉"; break;
                                            case 1: emojis = "🔥🐉"; break;
                                            case 2: emojis = "🔥🐉"; break;
                                            default: emojis = "🔥🐉"; break;
                                        }

                                        amountOfSabotage = 0
                                        if (sabotagedDragons > 0) amountOfSabotage += 1
                                        if (sabotagedHovels > 0) amountOfSabotage += 1
                                        if (sabotagedMiningCamps > 0) amountOfSabotage += 1
                                        if (sabotagedGold > 0) amountOfSabotage += 1
                                        currentAmountOfSabotage = 1

                                        if (sabotagedDragons > 0) {
                                            eventText += (defended ? app.formatEnglishNumber(sabotagedDragons, true) : app.formatEnglishNumber(sabotagedDragons))
                                            eventText += " dragon" + (sabotagedDragons > 1  ? "s" : "")
                                            emojis += " 🐲"
                                            currentAmountOfSabotage += 1
                                            if (defended) {
                                                eventText += " was lost in vain"
                                            }
                                        }

                                        if (sabotagedHovels > 0) {
                                            if (currentAmountOfSabotage > 1)
                                                eventText += ", "
                                            if (currentAmountOfSabotage == amountOfSabotage && amountOfSabotage > 1)
                                                eventText += " and "
                                            eventText += app.formatEnglishNumber(sabotagedHovels) + " hovel" + (sabotagedHovels > 1  ? "s" : "")
                                            emojis += " 🔥"
                                            currentAmountOfSabotage += 1
                                        }

                                        if (sabotagedMiningCamps > 0) {
                                            if (amountOfSabotage > 2)
                                                eventText += ", "
                                            else if (currentAmountOfSabotage == amountOfSabotage && amountOfSabotage > 1)
                                                eventText += " and "
                                            eventText += app.formatEnglishNumber(sabotagedMiningCamps) + " mining camp" + ((sabotagedMiningCamps > 1) ? "s" : "")
                                            if (sabotagedMiningCamps > 100)
                                                emojis += " 🔥"
                                            if (sabotagedMiningCamps > 1000)
                                                emojis += " 🔥"
                                            if (sabotagedMiningCamps > 10000)
                                                emojis += " 🔥"
                                            currentAmountOfSabotage += 1
                                        }

                                        if (sabotagedGold > 0) {
                                            if (currentAmountOfSabotage == amountOfSabotage && amountOfSabotage > 1) {
                                                if (amountOfSabotage > 2) eventText += ","
                                                eventText += " and "
                                            }
                                            eventText += app.formatEnglishNumber(sabotagedGold) + " gold"
                                        }

                                        eventText += ". "
                                    }

                                    if (dragonsKilled == 1)
                                    {
                                        eventText += "One of the sabotager's dragons "
                                        switch ((((sabotagedGold + sabotagedHovels + sabotagedMiningCamps) << 4) + sabotagedGold + sabotagedMiningCamps + sabotagedDragons + dragonsKilled) % 16) {
                                            case 1: eventText += "took a killing blow from an arrow and fell out of the sky."; break;
                                            case 2: eventText += "could not withstand the might of a magical defensive force conjured by one wise wizard."; break;
                                            case 3: eventText += "was hit by " + ((sabotagedGold % 2 + 1) * (sabotagedMiningCamps + 1) * 2) + " arrows."; break;
                                            case 4: eventText += "was accidently burned to death in the chaos."; break;
                                            case 5: eventText += "flew off and didn't come back. Who trained that dragon?"; break;
                                            case 6: eventText += "never returned."; break;
                                            case 7: eventText += "was hit by a rock thrown from a catapult."; break;
                                            case 8: eventText += "met its match."; break;
                                            case 9: eventText += "was defeated by several well organised soldier squads."; break;
                                            case 10: eventText += "was stabbed in the heart by a brave and daring soldier."; break;
                                            case 11: eventText += "was scared into a vortex and couldn't escape."; break;
                                            case 12: eventText += "witnessed the death of its trainer and took to the skies, never to return."; break;
                                            case 13: eventText += "heard the cry of an ancient and left to follow the calling."; break;
                                            case 14: eventText += "was hit by the might of a dark and well prepared spell."; break;
                                            case 15: eventText += "was taken down by the power of an allegiance between soldiers and wizards."; break;
                                            default: eventText += "was also killed."; break;
                                        }
                                    }
                                    else if (dragonsKilled > 1)
                                    {
                                        eventText += "The sabotager lost " + app.formatEnglishNumber(dragonsKilled) + " "
                                        switch (((((sabotagedGold + sabotagedHovels + sabotagedMiningCamps) << 6) + sabotagedGold >> 3)) % 34 ) {
                                            case 0: eventText += "dragons due to an act of God."; break;
                                            case 1: eventText += "dragons. Their ferocious cries could be heard far across the land."; break;
                                            case 2: eventText += "dragons."; break;
                                            case 3: eventText += "dragons after being struck down by " + app.formatEnglishNumber((sabotagedGold % 5 + 1) * (sabotagedMiningCamps + 1) * ((dragonsKilled + 1) * 3)) + " arrows."; break;
                                            case 4: eventText += "dragons into a vortex!"; break;
                                            case 5: eventText += "dragons in a storm."; break;
                                            case 6: eventText += "of their finest dragons."; break;
                                            case 7: eventText += "dragons trying to cross a bridge on the way back."; break;
                                            case 8: eventText += "dragons."; break;
                                            case 9: eventText += "dragons against the might of the forces they were up against!"; break;
                                            case 10: eventText += "dragons in a storm."; break;
                                            case 11: eventText += "dragons amongst the chaos."; break;
                                            case 12: eventText += "dragons."; break;
                                            case 13: eventText += "dragons in a gale."; break;
                                            case 14: eventText += "dragons due to not enough food being around to feed them."; break;
                                            case 15: eventText += "of their finest dragons."; break;
                                            case 16: eventText += "dragons."; break;
                                            default: eventText += " of their own dragons."; break;
                                        }
                                    }
                                    eventText += " " + emojis
                                
                                    app.updateGameStats()
                                    app.updatePlayerStats()
                                }
                                else if (event.event == "hostMessage")
                                {
                                    eventText = event.args.message
                                }
                                else if (event.event == "gameEnded")
                                {
                                    eventText = "The game ended."
                                    app.updateGameStats()
                                    app.updatePlayerStats()
                                    app.updateWinnerStats()
                                }

                                if (event.removed == false && eventText != undefined && eventText != ""
                                    && !handledEventTransactionHashes.includes(event.transactionHash))
                                {
                                    var tableEvent = { "time" : app.formatDate(eventTime), "text" : eventText }
                                    if (event.index !== undefined)
                                    {
                                        while (app.eventMessages.length < event.index)
                                        {
                                            app.eventMessages.push({})
                                        }
                                        Vue.set(app.eventMessages, event.index, tableEvent)
                                    }
                                    else
                                    {
                                        app.eventMessages.unshift(tableEvent)
                                    }
                                    event.removed = true
                                    handledEventTransactionHashes.push(event.transactionHash)
                                }
                            })
                        }

                        let outputFullEventLog = true
                        if (outputFullEventLog)
                        {
                            web3.eth.getBlockNumber(function(error, currentBlockNumber) {
                                var allEvents = cryptoKingdoms.allEvents({ fromBlock: 5551877, toBlock: 'latest' })
                                allEvents.get(function(error, events) {
                                    if (error) {
                                        log("allEvents error", error)
                                    }
                                    else {
                                        for (eventIndex in events)
                                        {
                                            event = events[eventIndex]
                                            event.index = events.length - eventIndex - 1
                                            handleEvent(0, event)
                                        }
                                    }
                                })
                            })
                        }

                        var turnCompletedEvent = cryptoKingdoms.turnCompleted(function(error, event) {
                            if (error) {
                                console.log("turnCompleted callback error", error)
                            }
                            app.updateGameStats()
                            app.updatePlayerStats()
                            app.updateWinnerStats()
                        })
                        var newPlayerJoinedEvent = cryptoKingdoms.newPlayerJoined(handleEvent)
                        var attackCompletedEvent = cryptoKingdoms.attackCompleted(handleEvent)
                        var spyReportedEvent = cryptoKingdoms.spyReported(handleEvent)
                        var sabotagedEvent = cryptoKingdoms.sabotaged(handleEvent)
                        var hostMessageEvent = cryptoKingdoms.hostMessage(handleEvent)
                        var gameEndedEvent = cryptoKingdoms.gameEnded(handleEvent)
                    }
                }
            })

            if (web3)
            {
                web3.version.getNetwork(function(error, networkIdentifier) {
                    if (error) {
                        log("getNetwork Error", error)
                    }
                    else
                    {
                        app.networkVersion = networkIdentifier

                        try {
                            if (typeof ethereum != "undefined") {
                                ethereum.on('networkChanged', function() {
                                    location.reload()
                                })
                            }
                        }
                        catch (ReferenceError) {
                            console.log("ethereum undefined")
                        }

                        // Main Network Game Contract Address
                        cryptoKingdomsContractAddress = "0x89f4d59797199b84447f8A2F7eceb0BEf962A9d6"

                        // Ropsten Test Network Game Contract Address
                        if (networkIdentifier == "3") {
                            cryptoKingdomsContractAddress = "0x6664486f02ffe7509d50c995ac5d5b5d89741a986a66bd3290208cccf6508d0f"
                        }

                        cryptoKingdomsContractAddress = web3.toChecksumAddress(cryptoKingdomsContractAddress)
                        cryptoKingdomsContract = web3.eth.contract(cryptoKingdomsContractABI)
                        cryptoKingdoms = cryptoKingdomsContract.at(cryptoKingdomsContractAddress)

                        // Account Info

                        app.updateAccountInfo()
                        
                        const filter = web3.eth.filter('latest');
                        filter.watch((error, result) => {
                            if (error) {
                                console.log("Error watching latest blocks:", error);
                            }
                            else {
                                app.updateAccountInfo()
                            }
                        });

                        // Game Info

                        app.updateGameStats()
                        app.updatePlayerStats()
                        app.updateWinnerStats()

                        // Events

                        app.setupEventLog()

                        // Countdown To Next Turn
                        var countdownInterval = setInterval(app.updateNextTurnTime, 1000)

                        document.onkeydown = function(event) {
                            event = event || window.event
                            var isEscape = false
                            if ("key" in event) {
                                isEscape = (event.key === "Escape" || event.key === "Esc")
                            } else {
                                isEscape = (event.keyCode === 27)
                            }
                            if (isEscape) {
                                app.cancelAllSelection()
                            }
                        }

                        async function wizardSneakInOut() {
                            while (window.location.href.includes("alpha")) {
                                await app.sleep(10 * 1000)
                                document.getElementById("wizardUnit").className = "wizardUnit hidden"
                            }
                        }
                        // wizardSneakInOut()

                        // Update last page update time whenever the page changes.
                        document.addEventListener("DOMSubtreeModified", function(event) {
                            app.lastUpdateTime = new Date()
                        }, false)
                    }
                })
            }

        </script>

    </body>

</html>
